# 💬 데일리 스크럼 💬
- 프로세스, 스레드 내용 복습
- 자바에서의 동시성 제어 학습하기
- 피드백 반영하여 리팩토링 진행하기
***
# 🧑🏻‍💻 학습한 내용 🧑🏻‍💻
# 프로세스

> 프로세스란 운영체제로부터 자원을 할당받아 독립적으로 실행되는 프로그램이다.
> 

---

프로세스란 컴퓨터에서 실행되고 있는 프로그램이라고 생각하면 편합니다.

좀 더 개발자처럼 말하자면 **운영체제**에게 **자원을 할당**받고 독립적으로 실행되는 프로그램이라고 말할 수 있습니다.

독립적이라는 말처럼, 프로세스는 각각 독립적으로 동작하며, 각각 할당받은 자원을 독립적으로 소유하고 있습니다.

이때, 프로세스간 통신이 필요하다면 IPC(Inter-Process Communication)을 이용해서 프로세스간 데이터 교환이 가능합니다.

이러한 프로세스에는 다음과같은 상태가 존재합니다.

`생성`

- 운영체제가 실행을 원하는 프로그램에게 **자원을 할당**하여 메모리에 로드하는 것
- 프로그램의 코드와 데이터가 메모리에 로드됩니다.

`준비`

- 프로세스가 준비큐에서 스케줄링을 기다리는 상태입니다.

`실행`

- CPU가 메모리에 로드된 프로그램의 명령어를 차례대로 실행하며, 프로그램이 실제 실행되는것
- 즉, CPU에 의해 실행되고 있는 상태입니다.

`대기` , `Block`

- I/O 와 같은 이벤트가 발생할 때, 해당 작업이 완료 될 때까지 프로세스가 기다리는 상태입니다. (이때, 프로세스는 아무 작업도 할 수 없게 됩니다.)
- 해당 작업이 완료되면 프로세스는 준비상태로 변하며 준비큐에서 스케줄링을 기다리게 됩니다.

`종료`

- 프로그램의 작업이 완료된 후 할당받은 자원을 다시 반환하면 종료 상태가 됩니다.
- 단, PCB에 내용(종료코드가 남아있음)이 남아있다면 이는 Zombie 상태라고 합니다.
- 이후 부모 프로세스가 PCB에 남아있는 종료코드를 읽어간다면 이는 완전히 종료된 상태라고 봅니다.

# 스레드

> 한 프로세스가 가진 자원 및 메모리를 공유하는 한개 이상의 실행단위이다.
> 

---

스레드는 하나의 프로세스에 속해있는 **작업 단위**라고 보면 편합니다.

운영체제로부터 프로세스가 할당받은 자원들 중 `Code`, `Data`, `Heap` 영역은 프로세스에 속한 스레드 모두 공유하게 됩니다.

다만, 각각의 스레드마다 `Stack` 영역은 스레드 독립적으로 가지고 있게 됩니다.

이러한 스레드를 가지고 우리는 프로그램을 더 효율적이고, 빠르게 만들 수 있습니다.

이때 스레드는 **동시성**과 **병렬성**을 이용하여 여러작업을 효율적으로 처리할 수 있게 됩니다.

# 프로세스와 스레드 차이

---

프로세스와 스레드의 차이를 표를 통해 정리해보도록 하겠습니다.

|  | 프로세스 | 스레드 |
| --- | --- | --- |
| 정의 | 실행되고 있는 프로그램 | 프로세스 내에서 존재하는 한 개 이상의 작업단위 |
| 자원 공유 | 프로세스간 독립적인 자원을 가지므로 자원 공유 불가능 | 프로세스 내의 Code, Data, Heap 영역은 여러 스레드간 공유 가능 |
| 메모리 구조 | Code, Data, Heap, Stack으로 이루어짐.  | 프로세스의 Code, Data, Stack 영역을 공유하여 사용하지만 독립적인 Stack영역을 보유 |
| 생성 비용 | 운영체제로부터 자원을 할당받아야 하기 때문에 생성비용이 크다. | 프로세스 내에서 생성되므로 상대적으로 생성비용이 적음 |

# 컨텍스트 스위칭

> 현재 실행중인 작업을 중단하고, 다음 실행할 작업의 상태로 전환하는 과정
> 

---

CPU의 개수는 유한적이기 때문에 한번에 처리할 수 있는 명령의 개수또한 정해져있다. 하지만, 사용자는 여러 작업을 매순간 실행하고 있으며, 이를 수행하기 위해 열심히 CPU는 일하고 있다.

단, 하나의 CPU는 한번에 하나의 일(명령)만 수행할 수 있다.

따라서, **컨텍스트 스위칭**을 통해 여러 작업을 바꿔가며 수행하게 된다.

컨텍스트 스위칭을 쉽게 말하자면 다음과 같다. 

**현재 작업을 중단하고, 다음 실행될 작업으로 전환하는 과정.**

그리고 이러한 과정을 통해 컨텍스트 스위칭이 이뤄진다.

1. 현재 실행중인 프로세스의 **레지스터**, **프로그램 카운터**(PC), **스택 상태**를 PCB에 저장한다.
2. 다음 실행할 프로세스의 이전 상태를 PCB로부터 복원한다.
3. CPU가 새로운 프로세스를 실행한다.

단, 컨텍스트 스위칭 과정에서 오버헤드가 발생할 수 있다는 단점이 존재한다.

+) 스레드보다 프로세스간 컨텍스트 스위칭이 더 많은 비용이 발생하게 된다.

# 스레드 오버헤드

> 멀티스레드 환경에서 성능저하를 발생시키는 추가비용
> 

---

위에서 컨텍스트 스위칭 과정에서 오버헤드가 발생할 수 있다고 하였다.

컨텍스트 스위칭 외에도 다양한 상황에서 **오버헤드**가 발생할 수 있으며 다음과 같은 상황이 있다.

- **동기화 비용**
    - 여러 스레드가 공유 자원에 접근하기 위해 락(Lock)경쟁을 하게 되는데 이때, 성능이 저하될 수 있다.
- **메모리 사용 증가**
    - 각 스레드는 독립적인 Stack영역을 갖기 때문에, 너무 많은 스레드가 생성될 경우 **메모리 사용량이 급증**할 수 있다.
    - 이때, 너무 많은 스레드는 자연스럽게 컨텍스트 스위치 비용또한 높아지게 된다.

# 자바에서 Thread Class 상속과 Runnable Interface 구현하는 차이

---

Thread와 Runnable의 가장 큰 차이점은 Thread는 클래스이며 Runnable은 인터페이스라는 점이다.

Thread와 Runnable은 Java5 이전부터 존재하던 자바의 멀티 쓰레드 기반 동시성 프로그램을 만들기 위한 방법이다.

Java의 버전이 올라가면서 동시성 프로그램을 위한 방식이 많이 나왔지만, 여기서는 Thread와 Runnable에 대해서 알아보도록 하겠다.

### Thread

Thread는 쓰레드를 만들기위해 Java에서 미리 만들어놓은 Class이다. 

새롭게 쓰레드를 만들기 위해선 해당 클래스를 상속받는 클래스를 만들어서 start() 메서드를 실행하면된다.

```java
public class TestThread extends Thread {
	
	@Override
	public void run() {
		System.out.println("thread print");
	}
}
```

위와같이 생성하고 Main 클래스에서 아래와같이 적고, 실행하면된다.

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        TestThread testThread = new TestThread();

        testThread.start();
    }
}

```

이러면 스레드 하나가 새롭게 생성됐고, 작업을 하게된다. 참 쉽지않나?!

다만, 주의할점은 `run()` 메서드를 통해 실행하면 안된다. 이는 그저 인스턴스의 메서드를 실행시킨것 뿐 새로운 스레드를 생성시키지 않는다.

따라서, `start()` 메서드로 꼭 실행시켜야 한다.

이렇게 간단하지만 잘 쓰이지는 않는다. 그런 이유는 다음과 같다.

- 자바는 다중상속을 지원하지 않기 때문에 확장성이 떨어진다.
- 클래스를 만들어야한다.

## Runnable

바로 위에서 신나게 Thread를 비판하고 왔다. 

Thread를 잘 사용하지 않는다면 Runnable을 사용하다는건데 왜 그럴까?

이를 알기전에 Runnable을 간단하게 알아보면 Runnable은 이름에서도 알 수 있듯이 인터페이스이다. 

Thread와 같이 쓰레드 생성을 위해서 사용하는 방식중 하나이며, 아래와같은 방식으로 실행시킬 수 있다.

```java
public class TestRunnable implements Runnable{

    @Override
    public void run() {
        System.out.println("hi");
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        TestRunnable testRunnable = new TestRunnable();
        Thread test = new Thread(testRunnable);
        test.start();
    }
}

```

이런 식으로 만들어서 사용하면 된다. 

Runnable 인터페이스는 `run()` 추상메서드를 가지고있기 때문에 `implements` 할시 반드시 구현해주어야 한다.

Thread또한 Runnable을 implements하고 있기 때문에 이를 상속받을시 `run()`을 사용할 수 있다.

다시 이야기로 돌아와서, **왜 Runnable을 Thread보다 주로 사용하는 걸까**?

Thread의 단점으로 다중상속이 불가능한 자바에서 확장성이 매우 떨어진다고 하였는데, 이를 인터페이스라는 점에서 뒤집어 버릴 수 있다.

자바는 인터페이스를 1개이상 implements 할 수 있기 때문에 확장성이 좋으며, 상속받아야 하는 클래스가 있다면 그 클래스를 상속받으면 된다!

특히, **Runnable**은 **run() 추상메서드 하나만 가지고있기 때문**에 **함수형 인터페이스**이다. 이러한 특징덕에 `람다`로도 사용할 수 있다.

# Synchronized

---

멀티스레드 환경에서 공유자원에 대한 접근법은 매우 중요하다.

이를 무시하고 코딩하면 자신이 원하는 결과값을 얻을 수 없는 대참사가 일어나게 된다.

멀티스레드 환경에서 공유자원에 대해 안전한 접근을 위해 Java에서는 `synchronized` 키워드를 제공해준다.

synchronized 키워드를 붙이게 되면 해당 메서드 또는 블록이 **임계영역**으로 설정되어 공유자원에 하나의 스레드만 접근할 수 있게된다.

```java
public synchronized void incrementValue() {
	 this.value++;
}
```

하지만 임계영역의 크기와 실행시간에 따라 성능하락과 자원낭비가 심해질 수 있기 때문에 해당 키워드의 사용을 지양해보도록 하자.

사용하고자 한다면 필요한 부분만 최소화하여 사용하는 방식으로 사용하도록 하자.

# AtomicInteger

---

Atomic은 멀티스레드 환경에서 변수에서 발생할 수 있는 동시성 문제를 해결해주는 Java의 패키지이다.

int, long, boolean과 같은 변수타입별로 종류가 있으며 아래와같이 사용할 수 있다.

 

```java
private AtomicInteger atomicInteger = new AtomicInteger(0);
private AtomicLong atomicLong = new AtomicLong(0L);
private AtomicBoolean atomicBoolean = new AtomicBoolean(true);
```

Atomic은 CAS(Compare And Swap)알고리즘을 이용한다.

이는 Lock을 사용하지 않는다는 특징때문에, 성능이 매우 좋다.

CAS 알고리즘은 3개의 값을 이용하게 되는데 다음과같다.

1. 현재 값(V) → 메모리에 저장된 실제 값
2. 기대 값(E) → 내가 예상하는 현재 값
3. 새로운 값(N) → 변경하려는 값

동작과정은 다음과 같다.

1. 현재 값V가 기대 값 E와 같은지 확인
2. 같다면 V를 N으로 변경
3. 다르면 아무런 동작을 하지 않음

이러한 동작과정을 통해 Lock 없이도 원자적 연산을 수행할 수 있게된다.

# 자바에서 지원하는 동시성 관리

---

## Synchronized

- 메서드 또는 블럭 전체를 Lock으로 보호

```java
public synchronized void increment() {
	this.value++;
}
```

---

## ExecutorService

- 스레드 풀을 관리하는 방식
- `newFixedThreadPool(n)`을 이용하면 최대 n개의 스레드를 재사용함
- `newCachedThreadPool()`을 이용하면 필요할 때 스레드 생성 사용 후 제거 가능

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 0; i < 5; i++) {
            executor.execute(() -> System.out.println(Thread.currentThread().getName() + " 실행"));
        }

        executor.shutdown(); // 스레드 풀 종료
    }
}

```

이를 실행하면 1~5 스레드가 재사용되는 것을 볼 수 있다.

---

## Volatile

`Volatile`은 멀티스레드 환경에서 변수의 **가시성**(Visibility)을 보장해주는 키워드이다.

즉, 여러 스레드가 하나의 값을 읽을 때 최신의 값을 읽을 수 있는걸 보장해준다는 것이다.

하지만, 원자성은 보장하지 않는다는 주의점이 존재한다.

JVM에서 스레드는 실행되고 있는 CPU 메모리영역에 데이터를 캐싱해두기 때문에 캐싱 시점에 따라 여러 스레드가 다른 값을 읽을 수 있다.

volatile 키워드를 붙이게 되면 캐싱된 값을 읽어오는게 아닌 메인 메모리에 저장되어있는 값을 참조하기 때문에 항상 최신의 값을 볼 수있게 된다.

```java
public class Test {
	private volatile int value = 0;
}
```

---
***
회고
# 💪 K (Keep) 💪
- 요새 공부하면서 딥하게 찾아보는 습관이 아주 약간 생긴거같다. 이런 자세를 쭉 가진다면 나도 이제 습관성 딥다이브를 할 수 있겠지?
  
# 😫 P (Problem) 😫
- 과제의 Q&A를 통해 Controller와 View의 결합성을 낮추는방법에 대해 와닿지 않아서 케빈에게 물어보았다. 과연 어떻게하면 Controller와 View의 결합도를 낮출 수 있을까?

# 🫵 T (Try) 🫵
- 객체지향적으로 띵킹 해보자. 과연 Controller와 View 이를 떠나서 객체간의 결합도를 낮추기 위한 방법이 뭘까? 이거에 대해서 공부를 해보자.
