# 💬 데일리 스크럼 💬
- 블로킹, 논블로킹 복습하기
- 2주차 과제 진행하기
***
# 🧑🏻‍💻 학습한 내용 🧑🏻‍💻
# 동기 / 비동기

> 동기 : 다음 작업 수행을위해 이전 작업의 완료를 기다리는 방식
> 

> 비동기 : 이전 작업의 완료를 기다리지 않고 다음 작업을 수행하는 방식
> 

---

# 블로킹 / 논블로킹

> 블로킹 : 요청한 작업의 결과가 올때까지 대기(차단)하는 방식
> 

> 논블로킹 : 요청한 작업의 결과를 **기다리지 않고** 다음 작업을 수행하는 방식
> 

---

# 블로킹 VS 논블로킹 || 동기 VS 비동기

---

> 블로킹 VS 논블로킹 : 다른 작업의 요청때문에 현재 작업이 멈추느냐 안멈추느냐
`병렬실행과 관련된 개념`  → 논블로킹의 경우 병렬실행
> 

> 동기 VS 비동기 : 여러개의 요청 작업의 순서가 지켜지느냐
`출력순서와 관련된 개념`
> 

# 동기 / 비동기의 차이를 설명하고 파일 읽기 작업을 예시로 들어 설명해주세요

---

동기와 비동기 차이점은 바로 **요청 작업의 순서가 지켜지느냐 안지켜지느냐이다**.

이를 파일읽기 작업을 예시로 이해해보자. (Java코드 대신 JS를 이용하겠습니다.)

### 동기

```jsx
const fs = require('fs');

// 동기적으로 파일 읽기
const data = fs.readFileSync('example.txt', 'utf8');

console.log("파일 내용:");
console.log(data);

console.log("파일 읽기 완료.");
```

코드의 실행순서는 예상과 같이 **순서대로** 진행되게 됩니다. 

즉, `fs.readFileSync()` 의 **작업이 모두 끝나야** 다음`console.log()` 들이 실행되는 방식인 것이죠. 

### 비동기

```jsx
const fs = require('fs');

console.log("파일 읽기 시작");
// 비동기적으로 파일 읽기 
fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) {
        console.error("파일 읽기 중 오류 발생:", err);
        return;
    }
    console.log("파일 읽기 완료");
});

console.log("다른 작업 진행중...");
```

해당 코드의 출력결과는 다음과 같습니다.

```jsx
파일 읽기 시작
다른 작업 진행중...
파일 읽기 완료
```

즉, 파일을 읽는 작업을 요청하지만, 요청에 대한 완료를 기다리지는 않습니다. 그렇기 때문에 ‘다른 작업 진행중…’이 먼저 출력되는 것입니다.

여기서 이런 의문이 생길수도 있습니다. ‘파일 읽기가 매우 빨리 끝나면 ‘파일 읽기 완료’가 먼저 출력될 수 있지않나?’

하지만, 이 의문에 대한 대답은 ‘NO’ 입니다. 아무리 파일이 빨리 읽힌다고 하여도 ‘다른 작업 진행중’의 출력보다 빨리 출력이 될 순 없습니다.

이는, 파일 읽기 작업이 백그라운드에서 진행되는 시점에 이미 ‘다른 작업 진행중’의 `console.log` 가 실행되기 때문입니다. 파일이 다 읽혀서 콜백함수가 실행되는건 나중의 일인거죠.

# 블로킹과 논블로킹을 제어권 관점에서 설명해주세요.

> 블로킹의 제어권 : 작업을 요청할 때 제어권을 넘겨서 아무런 일도 할 수 없게 된다.
> 

> 논블로킹의 제어권 : 작업을 요청할 때 제어권을 넘기지만 실행한 후 바로 제어권을 돌려받으므로 다른 작업이 가능하다.
> 

---

블로킹과 논블로킹의 제어권에 대해 알아보기 위해 다시 파일 읽기 예시를 봐봅시다.

- 프로세스 스레드 관점에서 보면 좋을듯함 (시스템 레벨) || 동기 비동기는 코드단계로 이해해보기
- 네트워크요청
- 데이터베이스 쿼리보내기

### 블로킹

```jsx
const fs = require('fs');

// 동기적으로 파일 읽기
const data = fs.readFileSync('example.txt', 'utf8');

console.log("파일 내용:");
console.log(data);

console.log("파일 읽기 완료.");
```

`readFileSync` 가 실행되면 fs에게 모든 제어권이 넘어가게 됩니다. 

따라서, **제어권**을 잃게된 요청주체는 아무런 작업(`console.log("파일 내용:")` )을 할 수 없게 되는것이죠.

어떤 작업을 하기 위해선 `제어권`이 있어야 합니다.

이를 스레드에 대입해서 생각하면 **파일을 읽는 동안** **실행중인 스레드가 대기상태**가 되는거라고 볼 수 있습니다.

### 논블로킹

```jsx
const fs = require('fs');

console.log("파일 읽기 시작");
// 비동기적으로 파일 읽기 
fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) {
        console.error("파일 읽기 중 오류 발생:", err);
        return;
    }
    console.log("파일 읽기 완료");
});

console.log("다른 작업 진행중...");
```

`readFile` 을 통해 파일 읽기 작업을 요청하면 제어권을 잠시 넘겨주지만 실행후 바로 제어권을 돌려받습니다.

이를 통해 요청주체에게 **제어권**이 다시 생겼으니,`console.log("다른 작업 진행중...");` 코드를 바로 실행할 수 있는겁니다.

즉, 제어권을 가지고 있기 때문에 작업을 멈추지 않아도 되며, 다른 작업을 실행할 수 있게 되는겁니다.

이 또한 스레드에 대입해서 생각해보면, 논블로킹에서는 요청 작업 때문에 **현재 실행중인 스레드가 멈추지 않습니다**.

# 동기 + 블로킹과 동기 + 논블로킹 조합의 차이를 설명해주세요.

> **동기 + 블로킹** : 다음 작업 실행을 위해 **이전 작업의 완료가 필수**적인 방식
> 

> **동기 + 논블로킹** : 작업을 요청한 후 요청주체가 **주기적으로 결과를 확인**하며 순차적인 작업처리를 하는 방식
> 

> 비동기 + 블로킹 : 작업을 요청한 후 다음 작업을 하기까지 멈춰있는 방식
> 

> **비동기 + 논블로킹** : 작업을 요청한 후 **결과를 알림으로 받으며** 바로 다른 작업을 수행할 수 있는 방식
> 

---

`동기 + 블로킹`  와 `비동기 + 블로킹` 의 차이점이 와닿지 않음을 느낄수있다.

그렇게 느끼는게 자연스러우며, `비동기 + 블로킹` 의 경우 사용하지 않는 방식이라고 봐도 무방하다.

다만, `비동기 + 블로킹`에서 콜백함수를 사용할 경우 콜백함수의 return을 기다린다고 볼 수 있다.

동기 + 블로킹은 요청 작업의 마무리를 기다리고 있다.

### 동기 + 논블로킹

```java
class Task implements Runnable {
    @Override
    public void run() {
        // 비동기로 실행할 작업
        System.out.println("new thread run task");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Task());
        thread.start();

        // Non-Blocking이므로 다른 작업 계속 가능
        System.out.println("Main thread is running...");

        // Sync를 위해 스레드의 작업 완료 여부 확인
        while (thread.isAlive()) {
            System.out.println("Waiting for the thread to finish...");
        }
        System.out.println("Thread finished!");
        
        System.out.println("Run the next tasks");
    }
}
```

`동기 + 논블로킹`의 이해를 위해 해당 코드를 보면 좋다.

스레드를 생성하고 `run()` 을 통해 `논블로킹방식`으로 스레드가 실행되지만 `while` 문을 통해 해당 스레드가 종료될 때 까지 기다리는 것을 볼 수 있다. 이는 `동기 방식` 의 동작방식이다. 

따라서, 메인 스레드가 동작이 가능하지만, while문을 통해 요청 작업의 마무리를 기다리며, 작업 완료 후 다음 작업을 실행하는 모습에서 **동기방식**을 볼 수 있다.

여기서 포인트는 **메인 스레드가 멈추지 않는다**는 것이며, `동기 + 블로킹` 방식과의 차이를 가져온다.

# 비동기 I/O와 논블로킹 I/O는 같은 개념인가요? 두 개념이 어떻게 다르다고 생각하시나요?

> 동기 I / O : 스레드는 IO 작업이 시작되고 종료될때 까지 다음 작업을 진행할 수 없는 방식 (대기큐 X)
> 

> 비동기 I / O : 스레드는 I / O 작업을 커널에게 요청하고 다른 작업의 수행을 하며, IO 작업 완료시 알림을 받고 처리하는 방식이다.
> 

> 논블로킹 I / O : 커널에게 IO 작업이 끝나는지 주기적으로 확인하고, 동시에 다른 작업이 수행 가능한 방식이다.
> 

> 블로킹 I / O : IO 작업동안 프로세스 또는 스레드는 작업을 중지한채 IO 작업의 완료를 기다리는(대기) 방식 (대기큐 O)
> 

---
<img width="480" alt="image" src="https://github.com/user-attachments/assets/74240ef5-1ced-4f9f-b536-2b1ba339a3a5" />

동기 IO 와 비동기 IO의 동작방식

출처 : https://learn.microsoft.com/ko-kr/windows/win32/fileio/synchronous-and-asynchronous-i-o

### 논블로킹 IO

- 요청을 보내는 즉시 데이터의 유무와 상관없이 바로 응답이 돌아온다.
- 만약 데이터가 없다면 `EWOULDBLOCK` 메시지를 반환해서 데이터가 없다는걸 알려준다.
- 마치 Polling과 같이 동작한다고 생각하면 편하다.

# 멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법은 어떤것이 있나요?

---

이를 알기위해서는 다음과 같은 정보를 알고있으면 좋을거같다.

### 멀티스레드 환경에서 블로킹 IO를 사용하면 어떻게 작업이 진행될까?

멀티 스레드 환경이란 프로세스 안에서 하나의 스레드가 아닌 여러 스레드가 작업을 하는걸 말한다.

이런 환경에 블로킹 I / O를 접목시키면 어떻게 될까?

<aside>
💡

블로킹 I/O

블로킹 I/O란 I/O 작업의 완료가 될때까지 스레드 또는 프로세스가 `대기상태`로 변하는 방식을 말한다.

</aside>

멀티스레드 환경에서 하나의 스레드가 IO 작업이 발생했다고 가정해보자.

해당 스레드는 대기상태로 대기큐에 들어가게 되며, OS는 대기 상태가 아닌 스레드를 실행하게 되며, 이 순간에 컨텍스트 스위칭이 발생하게된다.

또한, IO 작업이 완료된 경우 커널의 신호를 받고 대기중인 스레드가 깨어나게 된다. 이때 깨어난 스레드로의 컨텍스트 스위칭이 발생하게 된다.

<aside>
💡

논블로킹 I / O 가 사용된다면?

논블로킹 I / O 가 적용된다면 IO 요청이 발생한 스레드가 대기상태로 들어가지 않으므로 컨텍스트 스위칭이 발생하지 않는다. 

스케줄링에 의한 컨텍스트 스위칭인 발생하겠지만, 대기상태로 변함에 따라 발생하는 컨텍스트 스위칭은 발생하지 않는다.

</aside>

### 위와같은 환경에서 컨텍스트 스위칭 오버헤드는 언제 발생할까?

---

컨텍스트 스위칭이 빈번하게 일어나는 경우 오버헤드가 발생할 수 있다.

멀티스레드 환경에서 많은 수의 스레드에서 IO 작업이 일어난 경우 OS에서는 빈번하게 컨텍스트 스위칭이 발생하게 된다.

### 그렇다면 오버헤드를 어떻게 줄일 수 있을까?

---

### Thread Pool

많은 수의 스레드에서 IO 작업이 발생한 경우 오버헤드가 발생한다고 하였다.

그렇다면 스레드의 수를 적절히 조절한다면 오버헤드를 줄일 수 있지 않을까?

이를 위해서 `ThreadPool`을 사용할 수 있다.

ThreadPool을 이용하면 미리 일정 개수의 스레드를 생성하여 관리할 수 있다. 이를 통해 스레드의 개수가 무한정 커지는 것을 막을 수 있으며, 추가적으로 스레드 생성 및 삭제시 발생하는 오버헤드 또한 줄일 수 있게된다.

---

### IO 처리 전용 스레드

스레드에서 IO가 발생한 경우 대기상태로 인한 컨텍스트 스위칭이 발생한다고 했다. 그렇기에 많은 수의 스레드에서 IO가 발생하면 자연스럽게 컨텍스트 스위칭의 오버헤드가 발생하게 된다.

이를 해결하기 위해 IO 작업을 처리하는 스레드를 따로 둬 오버헤드를 줄이는 방식을 생각해볼 수 있다.

**동작방식**은 다음과 같다.

1. 작업 스레드에서 IO 작업이 발생한 경우 **IO작업을 큐에 넣어놓고** 다른 작업 수행
2. **IO 전용 스레드**에서 큐에서 작업을 꺼내와 **IO작업 수행**
3. IO작업 완료되면 요청했던 스레드에게 결과를 전달하여 후작업을 수행

---
***
회고
# 💪 K (Keep) 💪
- 주제를 공부하는데 있어서 궁금한걸 알아서 찾고, 그거에 대해서 깊이 공부하는 습관이 잡혀나가고 있는거같다. Keep Going!
  
# 😫 P (Problem) 😫
- 오늘은 아무문제 없는듯하다?! (아마?!)

# 🫵 T (Try) 🫵
- 내일은 좀 더 알차게 보내보도록 하자.
