# 💬 데일리 스크럼 💬
- 1주차 과제를 비동기프로그램으로 만들어보자.
***
# 🧑🏻‍💻 학습한 내용 🧑🏻‍💻
# 리스코프 치환원칙이란?

---

1주차 딥다이브를 진행할 때 SOLID 원칙에 대해서 조사했습니다.

이때 **L**이 바로 오늘 알아볼 **리스코프 치환원칙**을 말하고있는데요. 이는 무엇이고 얼마나 중요하길래 SOLID 원칙이라는 단어에 속해있는 걸까요?

리스코프 치환원칙을 아주 쉽게 설명하는 한 문장은 이것입니다.

> **서브타입**은 언제나 **기반 타입**으로 **교체**할 수 있어야한다.
> 

---

다만, 말은 쉽습니다. 이를 더 알아보기 위해 **기반타입**과 **서브타입**에 대해서 알아보겠습니다.

❓기반타입이란?</br>

❗서브타입이 상속하거나 구현해야하는 **상위 클래스** 또는 **인터페이스** </br>

❓서브타입이란? </br>

❗기반타입을 **상속** 또는 **구현**한 **하위 클래스** </br>

---

리스코프 치환원칙에 대해 말할때 **서브타입은 언제나 기반타입으로 교체할 수 있어야 한다**고 했는데요. 

저희는 개발자가 될 사람들이기 때문에 코드로 한번 쉽게 알아보겠습니다.

```java
class Rectangle { // 기반 타입
	protected int width;
	protected int height;
	
	// getter및 setter가 있습니다.
	
	public int calculateArea() {
		return width * height;
	}
}

class Square extends Rectangle { // 서브타입
	public Square(int length) {
		super(length, length);
	}
}
```

현재 코드상으로는 문제 없어보입니다. 다만, 아래의 경우를 봐볼까요?

```java
Square 정사각형 = new Square(5);
정사각형.setWidth(10);

System.out.println(정사각형.calculateArea());
```

이 코드의 출력결과를 생각해보면 기대했던 100과는 달리 50이 나오는걸 깨달을 수 있습니다.

즉, 예상했던 결과가 틀려버리게 됩니다. 이를 어떻게 고칠 수 있을까요?

```java
class Square extends Rectangle { // 서브타입
	public Square(int length) {
		super(length, length);
	}
	
	@Override
	protected void setHeight(int newH) {
		this.width = newH;
		this.hegith = newH;
	}
	
	@Override
	protected void setWidth(int newW) {
		this.width = newW;
		this.hegith = newW;
	}
}
```

이런 식으로 Rectangle의 setter를 오버라이딩하는 방식이 있을겁니다. 이러면 해결이 됐습니다.

문제를 해결했는데 찝찝하지 않으신가요? 찝찝하지 않다면 안됩니다. 반성하세요.

이 코드는 리스코프 치환원칙을 보기좋게 **위반**하고있습니다.

<aside>
❗

우리가 흔하게 아는 Setter는 하나의 값만 변경하는건데?

</aside>

즉, 이 코드는 우리가 흔하게 아는 규범을 범하고 있습니다. 물론 프로젝트를 혼자 진행하거나 소수의 인원으로 진행된다면 이는 큰 문제가 되지 않습니다.

다만, 새로운 개발자가 왔을때 Setter를 호출했는데 값이 두개이상이 바뀌어 버린다면 이상하게 생각하지 않을까요?

즉, 여기서 리스코프 치환원칙에서 지켜야하는 중요한 특징이 나오게됩니다.

- **파생 클래스**(서브타입)은 **기반 클래스**(기반타입)의 **의도**를 정확히 파악해야 하며 **이를 반영**해야한다.

파생클래스는 기반클래스의 의도를 아주 정확히 반영해야합니다.

왜냐하면 **파생클래스는 언제나 기반클래스로 교체가 가능해야하기 때문**입니다.

---

그러면 사각형 예제를 통해 다시한번 봐보도록 해봅시다.

Square(기반타입)의 Setter의 **의도**는 무엇이었을까요?

물론 이를 개발한 개발자만 알테지만 보통 하나의 값만 바뀌도록 하는게 Setter의 의도라고 볼 수 있습니다.

하지만 Rectangle에서 오버라이딩한 Setter는 두개의 값을 변경하고 있습니다. 이는 Square(기반타입)의 **의도를 벗어나고** 있으며, **치환조차 불가능**하게 됩니다.

---

그럼 대체 사각형 예제에서 완벽하게 리스코프 치환원칙을 적용할 수 있는 방식은 뭐가 있을까요?

해당 예제로는 리스코프 치환원칙을 지키도록 변경하는건 어렵습니다.

여기서 챙겨야할건 사각형따위가 아닙니다. 위에서 살펴본 특징을 항상 기억해야합니다.

<aside>
❗

**파생 클래스**(서브타입)은 **기반 클래스**(기반타입)의 **의도**를 정확히 파악해야 하며 **이를 반영**해야한다.

</aside>

즉, 중요한건 기반 클래스의 **의도**와 **계약**이 무엇인지 파악해야 한다는 것입니다.

---

<aside>
❓

이를 스프링부트로 확대해볼까요?

</aside>

<aside>
❗

여러분들이 개발자가되어 신기능을 개발한다고 한다면 여러분들이 초기코드 작성자가 될것입니다.

미래에는 다른 개발자가 여러분의 코드를 보고 이를 이용해야 할수도 있을텐데 어떻게 여러분이 초기에 작성한 의도를 보여줄 수 있을까요?

여기서 **테스트코드**의 중요성이 나오게됩니다.

해당 기능을 만들기위해 작성했던 **테스트코드**에는 여러분의 작성의도를 모두 담을 수 있을것입니다. 이렇게 테스트코드는 중요하답니다!

</aside>

---

# 그레이가 받은 피드백의 의도는?

피드백 원문

> 지금 Coffee클래스에서 getPrice()메소드를 오버라이딩하여 SHOT_PRICE를 차감하는것으로 이해했습니다. Beverage에서의 getPrice()는 샷이 추가된 만큼 가격을 올리는 구조인데 Coffee에서는 다시 또 가격을 낮추는게 직관적으로 이해되지는 않는것 같습니다. 혹시 **리스코프 치환 원칙**에 대해서 들어본 적 있으실까요? 해당 내용을 **위반**하는지를 기준으로 고민해봐도 좋습니다.
> 

### Beverage(기반타입)의 `getPrice()`

```java
@Override
public int getPrice() {
	return super.getPrice() + shotCount * SHOT_PRICE;
}
```

### Coffee(서브타입)의 `getPrice()`

```java
@Override
public int getPrice() {
	return super.getPrice() - SHOT_PRICE;
}
```

피드백에서 언급된 문제의 `getPrice()` 입니다. 이 코드에서 왜 리스코프 치환원칙이 언급되었을까요?

위에서 계속 말했던 리스코프 치환원칙에서 기억해야할 특징을 떠올린다면 쉽게 이해할수있습니다.

<aside>
❓

**Beverage**의 `getPrice()`의 **의도**

</aside>

<aside>
❗

제가 그레이가 아니라 정확한 의도를 파악하긴 어렵지만 코드상으로 파악해보자면
”**해당 메뉴 가격** + **추가한 샷만큼의 샷가격**” 이것이 의도라고 파악할 수 있습니다.

</aside>

Coffee(서브타입)의 `getPrice()`는 기반타입의 의도를 제대로 지키고 있나요?

Coffee의 `getPrice()` 에서는 **“해당 메뉴 가격 - 샷 가격”** 이런 동작을 보여주고 있습니다.

한 메서드에서 Coffee대신 Beverage를 파라미터를 받는다면 `getPrice()`가 의도대로 작동할까요?

```java
public int calculateTotalPrice(Beverage beverage) {
    return beverage.getPrice();
}
```

이런 메서드가 있다고 가정해 봅시다.

```java
Beverage beverage = new Beverage();
Beverage coffee = new Coffee();
```

이렇게 인스턴스를 생성하고 `calculateTotalPrice()` 메서드를 실행한다고 하면 정상작동을 할까요?

beverage는 의도한대로 되겠지만, coffee는 의도한대로 동작하지 않을것입니다.

따라서 이는 리스코프 치환원칙을 위반했다고 볼 수 있습니다.

정리해보자면 서브타입에서 **기반타입의 `getPrice()`의 의도**와는 전혀 다른 방향으로 오버라이딩을 진행했다는 점에서 리스코프 치환원칙을 언급해주신거 같습니다.
***
회고
# 💪 K (Keep) 💪
- 누군가에게 알려주는건 지식을 알려주는 행위는 어렵지만 뜻깊은 시간이다. 이런 경험을 해보게되어 좋았다.
  
# 😫 P (Problem) 😫
- 2주차 과제 비동기 너무 어렵다.

# 🫵 T (Try) 🫵
- 하지만 전체적인 개요를 알게되었으니 이를 적용하여 리팩토링을통해 응용하자.
