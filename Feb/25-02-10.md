# 💬 데일리 스크럼 💬
- 과제 제출하기
- 공유자원, 임계영역, 락, 동기화 학습 및 복습하기
***
# 🧑🏻‍💻 학습한 내용 🧑🏻‍💻
# 공유 자원

> 공유자원 : 여러개의 프로세스 또는 스레드가 접근하는 시스템 자원
> 

---

공유자원이라는 말과같이 이는 시스템 내에서 다수의 프로세스 또는 스레드가 함께 사용하는 자원을 말합니다.

대표적인 예로는 아래와같은 예시가 있습니다.

- 파일 시스템
- 네트워크 프린터
- 메모리
- 데이터베이스

공유자원을 이용하는 이유는 시스템의 효율성을 높일 수 있기 때문입니다.

만약 프로세스 또는 스레드 각각마다 자원을 따로 가지게된다면 해당 데이터를 동기화하는 과정에서도 많은 리소스가 들것이고, 이는 유한한 자원으로 돌아가는 컴퓨터 시스템에서 치명적으로 동작할 것입니다.

# 임계 영역

> 임계 영역 : 공유자원을 사용하는 코드 영역
> 

---

임계영역은 위에서 알아봤던 공유자원에 접근하는 영역이라고 생각하면 편합니다.

공유자원의 예시로 데이터베이스를 들었는데요. 임계영역과 함께 설명하자면

데이터베이스에 접근하고 작업을 하는 코드부분이 임계영역이라고 볼 수 있습니다.

이런 임계영역은 왜 필요한걸까요? 바로 멀티프로세스 또는 멀티 스레드 환경이 존재하기 때문입니다.

이러한 환경에서는 공유자원에 대한 여러 요청이 있을 수 있으며 제대로 처리해주지 않는다면 **데이터 무결성이 깨지고** **Race Condition이 발생**하게 됩니다.

이런 문제점은 `Lock`, `Mutex`와 같은 동기화 매커니즘을 이용해서 해결할 수 있습니다.

# 동기화

> 동기화 : 멀티스레드 환경에서 공유자원 접근으로 인한 문제점을 방지하고 접근 주체들의 순서를 관리하는 과정
> 

---

위의 임계영역에서 만약 동기화과정이 없다면 데이터 무결성이 깨지고 Race Condition이 발생할 수 있다고 했습니다.

이러한 문제점을 해결하기 위한 방법이 바로 **동기화**입니다.

동기화는 다음과 같은 특징을 통해 문제점을 해결하게 됩니다.

- 순서 보장
- 공유 자원 보호
- Race Condition 문제 해결

단, 주의할점은 동기화는 데이터(공유자원)를 업데이트하는 과정이 아닙니다.

공유자원을 안전하게 사용하고자 여러 접근주체들을 제어하는 과정입니다.

이러한 동기화 방식에는 다음과 같은 방식이 사용됩니다.

- Lock
- Mutex
- Condition Variable
- Semaphore

# 락

> 락 : 임계영역에 하나의 스레드만 접근할 수 있도록 제한하는 기법
> 

---

락은 자물쇠를 떠올리면 쉽게 이해가 가능합니다.

위에서 멀티스레드 환경에서의 공유자원 사용시 발생할 수 있는 문제점에 대해서 알아보았습니다. 또한 이러한 문제점을 해결하기 위해 동기화 과정이 매우 중요하다는것을 깨달았죠.

락은 이런 동기화 기법중 하나입니다.

락은 상호배제를 만족시킵니다. 이를 어떻게 만족시킬까요?

임계영역이 존재한다고 했을때, 하나의 스레드 또는 프로세스만 이 영역에 접근 가능하도록 자물쇠로 잠그거나 푸는 과정을 통해 상호배제를 만족시킬 수 있습니다.

락을 통해 **데이터 무결성**, **Race Condition**, **교착 상태**등 여러 문제를 해결할 수 있지만 꼭 기억했으면 좋은 키워드는 `원자성`입니다.

락의 중요한 특징중 하나는 **원자성**을 보장한다는 것입니다.

따라서 데이터가 변하거나 변하지않는(작업이 중간에 실패한경우) 상태를 유지하게되며, 데이터의 안전성과 일관성 보장하게 됩니다.

# 원자성

> 원자성 : 작업이 완료되거나 완료되지 않거나. 두 상태만 존재하는 성질
> 

---

Lock의 중요한 특징으로 원자성을 꼽았었습니다.

원자성에서 원자는 작업을 더이상 쪼갤 수 없는 실행단위를 말합니다.

원자성은 이러한 원자단위의 작업이 성공또는 실패의 단 두가지 상태만 가지는 것을 말합니다.

근데 Lock을 사용하면 왜 원자성을 보장받을 수 있을까요?

그 이유는 Lock을 통해 상호배제 특성을 가져감으로써 한 스레드의 작업에 다른 스레드가 간섭할 수 없게 되면서 그로인한 작업중단이 발생하지 않기 때문에 원자성을 지킬 수 있는 것입니다.

# 상호배제(Mutual Exclusion)

> 상호배제 : 임계영역에 하나의 스레드 또는 프로세스만이 접근할 수 있는것
> 

---

상호배제는 한 임계영역에는 단 하나의 스레드 또는 프로세스만이 접근할 수 있는 특성을 말합니다.

이러한 특성 덕에 Lock 이용시 원자성 보장을 할 수 있는 것입니다.

# 진행(Progress)

> 진행 : 대기큐가 차있고 임계영역이 비어있을 때 무조건 한 스레드 또는 프로세스가 임계영역에 들어가 실행해야하는것
> 

---

진행(Progress)는 동기화의 특성중 하나입니다. 

만약 임계영역에 접근하기 위해 대기하는 스레드가 한개 이상이고, 임계영역이 비어있다면 무조건 하나의 스레드가 임계영역에 들어가 작업을 해야한다는 특성입니다.

이는 `Condition Variable`에서 적용된 매커니즘입니다.

# 유한한 대기(Bounded Wating)

> 유한한 대기 : 언젠가는 실행되어야하는 특성
> 

---

동기화 과정상 항상 작업을 기다리는 스레드가 존재합니다.

유한한 대기(Bounded Waiting)은 이러한 스레드가 영원히 대기만 하지 않도록 방지하기 위한 특성입니다.

# 데드락

> 데드락 : 교착상태라고도 하며, 두개 이상의 스레드가 서로 자원을 가지며 상대방의 자원을 요청하여 영원히 기다리기만 하는 상황
> 

---

해당 문제는 두 개 이상의 스레드가 서로가 가진 자원의 해제를 기다리며 무한 대기 상태에 빠질 수 있는 문제입니다.

이는 `교착 상태`라고도 불리는 문제입니다.

![image](https://github.com/user-attachments/assets/ab46fa71-7750-4113-ae44-f589ce5fb463)

<aside>
❓

어떤 상황인가요

</aside>

<aside>
❗

- 남자는 햄버거를 소유하고 있으며 감튀를 원하는 상태
- 여자는 감튀를 소유하고 있으며 햄버거를 원하는 상태

이러한 상황에서 서로 자원(햄버거, 감튀)를 소유만 하고있고 해제를 하지 않는다면 무한정 기다리는 상태가 될것입니다.

</aside>

# Race Condition

> Race Condition : 공유자원에 대해 여러 개의 스레드가 동시에 접근할 때 타이밍 또는 순서에 따라 작업결과에 영향을 줄 수 있는 상태
> 

---

여러 개의 스레드가 공유자원에 접근할 때 경쟁 상태(Race Condition)이 발생할 수 있는 문제입니다.

`경쟁상태`란 공유자원에 대해 여러 스레드(또는 프로세스)가 **동시에 접근**을 할 때, **타이밍**이나 **순서**에 따라 결과값에 영향을 줄 수 있는 상태를 말합니다. 

![image](https://github.com/user-attachments/assets/c15fbdaf-ff04-43b6-9f6b-6c12f542ab17)

<aside>
❓

어떤 상황인가요?

</aside>

<aside>
❗

여러 사람(스레드)이 공용통장(공유자원)에 접근하는 상황입니다.

만약 공유통장에 100만원이 있다고 가정해봅시다.

이때 아주 비슷한 타이밍에 eric이 10만원, rick이 20만원, gray가 30만원을 출금한 후 잔액을 조회하는 상황입니다.

원래는 40만원이 남아있는게 정상적인 상황입니다.

하지만 `eric - 90` `rick - 80` `gray - 70` 이런 식으로 조회가 될 수 있는 문제가 발생하게됩니다. 이게 바로 경쟁상태 입니다.

</aside>

물론, 이 문제는 프로세스 사이에서도 일어날 수 있는 문제지만 스레드는 프로세스보다 더 많은 공유자원을 가지고있기 때문에 발생할 가능성이 더 높습니다.

# (선택) 기아 현상

> 기아 현상 : 영원히 대기만하게되는 상황
> 

---

만약 스케줄러의 스케줄링 방식이 SJF라고 해봅시다. 

이 경우에는 만약 작업시간이 조금남은 스레드 또는 프로세스가 계속해서 들어온다면 상대적으로 작업시간이 긴 스레드 또는 프로세스는 영원히 실행되지 못할것입니다.

이러한 현상을 기아현상이라고 합니다.

스케줄러 예시에서 이러한 현상을 해결하기 위해서는 MLFQ와 같은 스케줄링 방식을 사용하여 해결할 수 있습니다.

또한, 동기화의 특성중 `유한한 대기`를 통해 기아현상을 방지할 수 있습니다.

# 스핀락

> 스핀락 : 락을 얻을 수 있는지 계속해서 확인하는 방식
> 

---

스핀락은 임계영역에 접근하려는 스레드가 **락을 얻을 수 있는지**를 **계속해서 요청하는 방식**입니다.

저는 스핀락을 떠올렸을때 우선 **단점**이 먼저 떠오릅니다. 어떤 **단점**이 있을까요?

- **CPU 사용률 증가**
    - 스레드가 대기상태로 변하지 않고 계속해서 락을 사용할 수 있는지 체크를 하게되는 과정에서 CPU의 사용률이 증가하게됩니다.
- **비효율적 대기**
    - 만약 락 해제가 오래걸리는 작업인 경우 busy-waiting 상태가 오래 지속됩니다. 이로인해 다른 스레드 또는 프로세스가 이용해야 하는 CPU의 자원을 무의미하게 낭비할 수 있습니다.
- **단일 CPU에서의 부적합성**
    - 단일 CPU의 경우 한번에 한 작업만 가능하기 때문에 대기 스레드가 계속해서 락을 확인할 수 있는 방법자체가 없습니다. (락을 확인하기 위해선 이 스레드 또한 동작해야 하므로)

하지만 단점만 존재한다면 애초에 언급조차되지 않았을겁니다. **장점**을 알아보도록 하겠습니다.

- **빠른 락 점유 해제**
    - 만약 락이 빠르게 해제된다면 즉시 락을 획득할 수 있습니다.
- **컨텍스트 스위칭 없음**
    - 스레드 또는 프로세스가 대기상태로 변하지 않기 때문에 컨텍스트 스위칭이 발생하지 않습니다.
- **간단한 구현**
    - 다른 락 방식에 비해 비교적 간단한 방식으로 구현 가능

이런 특징들로 인해 스핀락은 다음과같은 작업에 효율적입니다.

- **락 점유가 매우 짧고, 빠른 응답이 필요한 작업**
    - 이는 대기상태로 가지않아 컨텍스트 스위칭이 동작하지 않기때문입니다.

# 낙관적 락

> 낙관적 락 : 충돌이 나지 않는다고 가정하고 공유자원에 대한 작업진행, 충돌 시 롤백으로 재실행하는 방식
> 

---

이 방식은 충돌이 나지 않을거라는 행복한 상상을 하며 락을 사용하지 않는 방식이다.

이러한 가정때문에 공유자원에 대해 다수의 스레드가 접근할 수 있습니다만, **데이터 충돌이 발생할 경우** 꼭! **롤백**을 통해 데이터를 복구하고 재실행을 해야합니다.

이러한 특징 덕분에 낙관적 락 방식은 **읽기 작업이 많고, 쓰기 작업이 적은 환경**에 찰떡입니다.

낙관적 락 방식의 **장점**은 다음과 같습니다.

- **데이터 경합이 거의 없는 환경에서 성능이 매우 뛰어나다.**
    - 락을 사용하지 않기 때문에, 락 사용으로 인한 오버헤드가 없다.
- **데이터 경합이 거의 없는 환경에서 병렬처리 효율 극대화**
    - 여러 스레드가 동시에 공유자원에 접근을해서 작업을 할 수 있으므로

낙관적 락 방식의 **단점**은 다음과 같습니다.

- **롤백 비용 발생**
    - 데이터 충돌이 일어난 경우 롤백을 필수로 해야하기 때문에, 롤백으로 인한 비용이 발생한다.
- **충돌시 성능 저하**
    - 충돌이 발생하면 롤백과 더불어 작업을 재실행해야 하므로 비용이 많이 발생하며, 시스템 성능 저하로 이어진다.
- **복잡한 구현**
    - 충돌 감지 및 롤백 기능을 구현해야하기 때문에 구현이 복잡하다.

낙관적 락의 **사용사례**는 다음과 같습니다.

- **데이터베이스 트랜잭션**
    - 데이터 충돌이 적은 데이터베이스 트랜잭션에서 락대신 낙관적 락 방식을 이용한 성능 향상

# 뮤텍스

> 뮤텍스 : 한번에 하나의 스레드만 공유자원에 접근할 수 있도록 하는 방식
> 

---

뮤텍스는 한번에 하나의 스레드 또는 프로세스만이 공유자원에 접근할 수 있도록 하는 특징이 있습니다.

또한, 락의 소유권 및 해제권한을 특정 스레드에게 부여한다는 점도 존재합니다.

특정 스레드에게 부여한다해서 작업 스레드와 락을소유권을 관리하는 스레드가 다를수 있나요?라고 묻는다면 둘이 같은 스레드라고 말해주고 싶습니다.

뮤텍스의 **동작방식**은 다음과 같습니다.

1. 락을 얻을 수 있는 요청 및 얻을 수 있다면 락 획득
2. 이후 접근 스레드는 대기큐에서 대기
3. 락의 소유권을 가진 스레드의 작업이 끝나면 `notify()`를 통해 대기하던 스레드 깨우기

뮤텍스의 **장점**은 다음과 같습니다.

- 한번에 하나의 스레드만 접근할 수 있기 때문에 데이터 무결성이 보장된다.
- 대부분의 운영체제에서 기본으로 제공되며, 동기화 문제에 쉽게 적용가능하다.

뮤텍스의 **단점**은 다음과 같습니다.

- 컨텍스트 스위칭 오버헤드
    - 대기큐에 들어갈때 대기상태로 변하므로 컨텍스트 스위칭이 발생합니다.
- 데드락 (교착상태) 가능성
    - 잘못된 락 해제 및 순서로 인한 데드락이 발생할 수 있습니다.
- 제한된 병렬처리
    - 하나의 한 스레드만 공유자원에 대해 작업할 수 있기 때문에 병렬성이 떨어집니다.

# 조건 변수(Condition Variable)

> 조건 변수 : 스레드가 특정 조건이 충족될때 까지 대기하거나, 한 스레드가 다른 스레드에게 신호를 배워 깨우는 매커니즘
> 

---

조건 변수(Condition Variable)은 스레드가 특정 조건이 충족될때 까지 대기하거나, 한 스레드가 다른 스레드에게 신호를 배워 깨우는 매커니즘입니다.

조건 변수 중 ‘조건’은 한 스레드가 작업을 수행하기 위해 반드시 충족해야 하는 조건입니다.

이러한 조건을 충족할 때까지 스레드는 대기하고 있으며, 조건 충족시 작업을 수행할 수 있게 됩니다.

조건 변수는 Mutex와 함께 주로 사용됩니다. 

Mutex와 함께 사용됨을 통해 안전하게 공유자원에 접근할 수 있게 됩니다. 

Mutex + 조건 변수 조합을 사용하게 되면 무한정 대기하지 않고 필요한 순간에 깨어나 작업을 실행할 수 있으므로 불필요하게 CPU를 낭비하지 않으며 높은 성능을 제공하게 됩니다. 

특정 조건을 만족하는지를 따지는 조건 변수의 특성에 따라 두가지 대기큐가 사용됩니다.

- 조건 변수 대기 큐
- 뮤텍스 대기 큐

### 조건 변수 대기 큐

조건 변수 대기 큐는 아직 작업을 위한 **특정 ‘조건’을 만족하지 못한 스레드가 대기**하는 큐입니다. 

### 뮤텍스 대기 큐

뮤텍스 대기 큐는 **특정 조건은 만족**했지만 **아직 락을 얻지 못해**서 대기하는 큐 입니다.

두가지 종류의 큐를 사용하는 이유는 다음과 같습니다.

- 뮤텍스 대기 큐에서는 락만 획득하면 실행됩니다. 이 큐만 사용하게 될 경우 특정 조건을 만족하지 않은 스레드 또한 실행될 수 있는 가능성이 존재하게 됩니다.

# Read-Write Lock

> Read-Write Lock : Read Lock과 Write Lock을 통해 읽기 작업시 상호배제 특성을 약화시켜 시스템 성능을 높이는 방식
> 

---

위에서 살펴본 Lock 방식은 모두 하나의 Lock또는 Lock을 사용하지 않는 방식이었습니다.

하지만, Read-Write Lock 방식은 두가지의 Lock을 사용하는 방식입니다.

Read-Write Lock 방식은 멀티 스레드 환경에서 **읽기 작업**과 **쓰기 작업**을 구분하여 락을 관리하는 동기화 매커니즘 입니다.

Reader의 경우 여러 스레드에서 동시에 접근해서 사용할 수 있습니다.

하지만, Writer는 한 스레드에서만 작업할 수 있습니다.

이 방식의 장점은 **읽기작업이 매우 많고 쓰기 작업이 적은 경우** 시스템 효율이 매우 좋습니다.

→ 그 이유는 Read 작업의 경우 여러 스레드가 동시에 접근이 가능하기 때문에 컨텍스트 스위칭이나 대기가 필요없고 Lock과 관련된 연산또한 소요되지 않기 때문입니다.

또한, Write 작업의 경우 상호배제가 적용되기 때문에 데이터의 무결성또한 보장됩니다.

하지만 아래와같은 단점또한 존재합니다.

- Reader가 계속 자원을 점유하게 될 경우 Wrtier가 **기아상태**가 될 수 있습니다.
- Reader와 Writer의 lock 순서관리가 제대로 안된다면 **데드락**이 발생할 수 있습니다.

# 세마포어

> 세마포어 : 하나의 공유자원에 대해 여러개의 스레드가 동시에 접근할 수 있도록 하는 매커니즘
> 

---

뮤텍스 방식에서는 락을 획득한 스레드에서만 락을 해제할 수 있었지만, 세마포어의 경우 접근한 스레드의 경우 해제가 가능합니다.

이는, 한 스레드가 세마포어를 획득하고 이에 접근한 다른 스레드가 해제할 수 있다는 말입니다.

세마포어에는 다음과 같은 종류가 있습니다.

### 바이너리 세마포어

바이너리 세마포어는 0또는 1의 값을 가질 수 있습니다. 이러한 특징 때문에 뮤텍스와 유사해 보이지만 위에서 알아봤듯이 소유권이 없다는 차이점이 있습니다.

이는 하나의 공유자원을 보호하는데 사용하게 됩니다.

### 카운팅 세마포어

위에서 살펴본 세마포어 입니다. 여러 개의 스레드가 동시에 공유자원에 대해 접근할 수 있으며, 소유권또한 없다는 특징이 있습니다.

# 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.

---

지금 떠오르는 공유자원은 데이터베이스가 있습니다. 

만약 공유자원이라는 개념없이 각 연결마다 1:1 로 매칭이 되어야 한다면 DB 요청개수만큼 DB가 존재해야 할것입니다. 이는 물리적으로도 한계가 존재하며 매우 비효율적일 것입니다.

따라서, 공유자원이라는 개념을 통해 데이터베이스 하나를 두고 요청과 N:1 관계를 맺을 수 있다고 생각합니다.

즉, 공유자원을 사용하는 이유는 시스템 상에서의 효율성 증진이 가장 큰 이유라고 생각합니다.

# 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?

---

임계 영역이란 공유자원과 관련된 연산이 모여있는 영역입니다. 

멀티 스레드 환경에서 임계 영역은 매우 중요합니다. 각 스레드들은 프로세스의 힙, 프로세스, 데이터 영역을 공유하고 있으며 이들이 모두 공유자원 입니다. 

만약 두개 이상의 스레드가 한 공유자원에 대해 동시에 접근하여 동기화없이 연산을 하게 될 경우 공유자원의 연산결과가 달라지는 일이 발생할 것입니다.

따라서, 한 공유자원에 대해 여러 요청주체가 생길 수 있는 환경에서는 임계영역에 대한 보호가 무조건적으로 필요합니다.

자세히말해, 영역의 보호가 되지 않을 경우 데이터 무결성이 깨지며, 경쟁상태가 발생하게 될 수 있습니다.

임계 영역에서 가장 많이 드는 예시로 은행시스템이 있습니다.

만약 계좌라는 임계영역이 지켜지지 않는다면 어느순간 계좌의 돈을 모두 잃어버릴수도 있는 것입니다.

아니면 조회만 했을뿐인데 돈이 출금될수도 있죠.

이렇게 시스템상에서 공유자원에 대한 동기화가 지켜지지 않는다면 해당 서비스는 신뢰받지 못하고 버려질 것입니다.

따라서, 임계영역의 보호는 매우매우 중요합니다.

# 동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.

---

동기화 매커니즘이란 멀티 스레드 환경에서 공유 자원에 접근할 때 접근 주체들의 순서를 관리하는 매커니즘 입니다.

이러한 매커니즘은 왜 필요한걸까요?

만약, 멀티스레드 환경에서 동기화가 존재하지 않는다면 공유자원에 접근하는 스레드마다 각기 다른 연산결과를 얻을 수 있으며 이로인해 데이터의 무결성이 완전히 무너지게 됩니다.

예시를 들어보겠습니다. 

1. 은행 예시
    
    > 여러 사람(스레드)이 공용통장(공유자원)에 접근하는 상황입니다.
    
    만약 공유통장에 100만원이 있다고 가정해봅시다.
    
    이때 아주 비슷한 타이밍에 eric이 10만원, rick이 20만원, gray가 30만원을 출금한 후 잔액을 조회하는 상황입니다.
    
    원래는 40만원이 남아있는게 정상적인 상황입니다.
    
    하지만 `eric - 90` `rick - 80` `gray - 70` 이런 식으로 조회가 될 수 있는 문제가 발생하게됩니다.
    > 
2. value에 대한 increment 작동
    
    > 만약 두개의 스레드가 존재하고 `int value = 0`  을 돌아가면서 1000번씩 increment 시킨다고 가정해봅시다.
    
    이때, 예상하는 결과는 2000 일 것입니다. 스레드1과 스레드2가 1000번씩 value를 ++ 하고 있으니까요.
    
    하지만 데이터 동기화 없이 코드 동작후 결과를 살펴보게 되면 2000에 못미치는 숫자들이 출력되는 것을 볼 수 있습니다.
    
    이 경우 또한 동기화가 없기 때문에 데이터 무결성이 지켜지지 않은탓에 발생하는 문제점 입니다.
    > 
3. 게임 랭킹
    
    > 여러분이 게임에서 점수를 열심히 모아 랭킹을 1등으로 만들고자 하는 상황입니다.
    
    그런데 개발사에서 랭킹에대해 동시성처리를 해놓지 않은 상황입니다.
    
    이렇게 될 경우에 랭킹 1등에 준하는 점수를 모았지만 동점자에 의해 갑자기 점수를 모두 잃을 수도 있습니다. 또는 2등으로 밀려날 수도 있겠죠.
    > 

# 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.

---

락은 임계영역을 보호하기위해 사용되는 매커니즘 입니다. 하나의 스레드가 임계영역에 들어가기전 락을 요청하고 락을 받으면 해당 영역에는 락의 소유권을 가진 스레드만이 접근할 수 있게 됩니다.

이렇게되면 데이터의 무결성을 지킬수가 있습니다. 이유가 뭘까요?

한 공유자원에 대해 하나의 스레드만 접근할 수 있기 때문입니다. 이렇게 되면 한 공유자원에 대한 읽기 외의 연산작업까지도 하나의 스레드에서만 작업이 가능하기 때문에 무결성이 지켜지게 됩니다.

이를 연장하게 되면 락은 원자성또한 만족합니다.

원자성이란 해당 작업의 연산이 성공하거나 실패하는 두가지의 경우만 가지고 있다는 개념입니다.

락을 이용하면 하나의 공유자원에 대해 하나의 스레드만이 접근 가능하다고 했습니다. 이렇게 될 경우 연산 작업에 다른 스레드의 작업이 끼어들 수 없게 됩니다. 이로인해 작업 중 중단이 발생하지 않으며, 원자성을 만족하게 됩니다.

# 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.

---

**뮤텍스**는 하나의 공유자원에 하나의 스레드만이 접근할 수 있다는 것입니다. 추가로 해당 스레드에서 **락의 소유권과 해제권을 모두 가지고 있게됩니다**.

**세마포어**는 하나의 공유자원에 대해 설정한 개수의 스레드가 동시 접근할 수 있습니다. 이때, **소유권이라는 개념 없이 접근한 아무 스레드에서나 세마포어를 해제할 수 있습니다**.

물론 바이너리 세마포어를 사용하면 뮤텍스와 유사해지지만 어찌됐든 소유권개념에서 차이점을 가지게됩니다.

뮤텍스를 사용하면 좋은 상황은 다음과 같습니다.

- 단일 자원에 대해 하나의 스레드만이 접근해야 하는 경우
- 즉, 데이터 무결성이 완전히 지켜져야 할 때
    - 뮤텍스는 정확히 하나의 공유자원에 대해 하나의 스레드만이 접근할 수 있습니다. 이로인해 다른 스레드가 작업에 끼어들 수 없게되고 데이터의 무결성이 보장되게 됩니다.

세마포어는 다음과 같은 상황에 좋습니다.

- 자원에 대해 다중 접근을 허용해야 할 때
    - 미리 설정한 개수만큼 스레드가 동시접근을 할 수 있게 되는 특성 덕분입니다.
    - 따라서, DB 커넥션풀, 스레드 풀 등에서 사용되고 있습니다.
***
회고
# 💪 K (Keep) 💪
- 딥다이브 아주 잘하고있다. 그대로만 킵고잉 해보자~!
  
# 😫 P (Problem) 😫
- 집중력이 흐트러질때가 종종있다...

# 🫵 T (Try) 🫵
- 쉴땐 쉬고 집중할땐 집중하는 자세 가지자. 이도저도 아닌건 최악이다.
