# 💬 데일리 스크럼 💬
- 남은 키워드 정리하기
- 2주차 과제 피드백 반영하기
***
# 🧑🏻‍💻 학습한 내용 🧑🏻‍💻
# (선택) 락-프리 (Lock-Free) / 웨이트-프리 (Wait-Free) 알고리즘 🍟

> 락-프리 : 락을 사용하지 않고 원자적(Atomic) 연산을 활용하여 동기화 처리하는 방식
> 

> 웨이트-프리 : 모든 스레드가 일정 연산 안에 반드시 작업을 완료할 수 있도록 보장하는 알고리즘
> 

---

### 락-프리 (Lock - Free)

---

락 프리 알고리즘은 말그대로 락을 사용하지 않고 동기화를 진행하는 방식입니다.

그렇다면 락없이 어떻게 동기화를 진행할 수 있는걸까요?

락 프리 방식에서는 락대신 `CAS`와 같은 원자적(Atomic) 연산을 사용하여 동기화 처리를합니다.

이 알고리즘의 **특징**은 다음과 같습니다.

- 원자적 연산을 이용한 동기화 방식
- 락을 사용하지 않기 때문에 스레드가 블로킹되지 않음 → 다른 스레드로 영향 가지 않음

### 웨이트-프리 (Wait - Free)

---

**웨이트 프리 알고리즘**은 **모든 스레드가 일정 연산 안에 반드시 작업을 완료**할 수 있도록 **보장**하는 알고리즘 입니다.

해당 알고리즘의 장점은 아무리 경쟁이 많이 일어나더라도 **언젠가 작업이 완료**되게 된다는 것입니다.

**특징**은 다음과 같습니다.

- **모든 스레드가 무한정 대기하지 않음**
- **우선순위 역전, 데드락 방지 가능**
    - 우선순위 역전 : 우선순위가 낮은 스레드가 락을 소유하고있어 우선순위가 높은 스레드가 실행되지 못하는 상황

이러한 특징을 이용하여 다음과 같은 상황에 적용하면 좋습니다.

- **락기반 동기화 방식이 성능 병목이 되는 경우**
- **실시간 시스템에서 응답 시간을 보장해야 하는 경우**

---

### 낙관적 락, 락-프리, 웨이트-프리

공부를 하다보니 락을 사용하지 않는 세 방식의 비교를 해보았습니다.

|  | 낙관적락 | 락-프리 | 웨이트-프리 |
| --- | --- | --- | --- |
| 충돌 발생시 | 롤백 후 재시도 | 일부 스레드는  | 모든 스레드는 유한한 연산내에 종료 |
| 데이터 접근 방식 | 충돌 감지후 해결 | CAS를 이용하여 계산 | 모든 스레드가 정해진 시간 내에 완료 |
| 성능 | 충돌 적을시 빠름 | 동시성 높지만 일부 스레드에서 무한 대기 가능성 있음 | 동시성 보장 (강력하게) |

# (선택) 분산 락 🎸

> 분산 락 : 분산 시스템에서 공유 자원에 대한 동시접근을 제어하기 위한 락 매커니즘
> 

---

**분산 락**은 분산 시스템에서 하나의 공유자원에 대해 접근하게 될 때 동시접근을 제어하기 위한 락 매커니즘 입니다.

이를 구현하기 위해 외부 시스템(DB, Redis, ZooKeeper..)을 사용하여 락을 관리하게 됩니다.

한 서버가 공유자원에 대한 락을 가져가게 되면 다른 서버에서는 대기해야하는 상황이 펼쳐지는거죠.

기본적인 분산락의 경우 뮤텍스와 같이 공유자원에 대해 한 서버만 사용할 수 있습니다.

다만, 차이점이라고 한다면 **뮤텍스의 경우 OS단에서 락을 관리**하게 되지만 **분산락은 네트워크 단에서 락을 관리**하게 됩니다.

근데 서버라고 하니까 이런 **문제점**이 발생할 수도 있을거 같습니다.

> **락을 소유하고있던 서버가 중간에 꺼지면 어떻게되지?**
> 

만약 해당 서버가 영원히 꺼지게 된다면 락은 그 누구도 가질수 없게 될것입니다.

이러한 상황을 방지하기 위해 락에 TTL을 설정하는 방식을 사용할 수도 있습니다.

# 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.

---

이 질문에 앞서 조건 변수와 뮤텍스에 대해 간단하게 짚고 가겠습니다.

- 조건변수 (Condition Variable)
    
    > 조건 변수(Condition Variable)은 스레드가 특정 조건이 충족될때 까지 대기하거나, 한 스레드가 다른 스레드에게 신호를 주고 깨우는 매커니즘입니다.
    
    조건변수의 역할은 다음과 같습니다.
    - 효율적인 스레드 대기 및 깨어남
    - Busy Waiting 방지
    > 
- 뮤텍스
    
    > 한 임계영역에는 하나의 스레드만이 접근할 수 있다는 락방식입니다.
    또한, 락의 소유권 및 해제권한을 특정 스레드에게 부여한다는 특징도 존재합니다.
    
    즉, 뮤텍스의 역할은 다음과 같습니다.
    - 임계영역 보호
    - 데이터 무결성 유지
    > 

주로 접근변수와 뮤텍스를 조합해서 사용하는 경우를 많이 보셨을겁니다.

그렇다면 왜 다른 락 방식이 아닌 뮤텍스와 함께 사용하는 걸까요?

### 스핀락과의 조합

> 스핀락은 일단 스레드가 대기하지 않고 계속해서 락을 얻을 수 있는지 확인하는 방식입니다. 이 방식은 특정 조건을 만족하면 깨어나는 조건변수의 동작방식에 상충되는 느낌을 받으셨을겁니다. 

따라서, 스핀락과 조건변수의 조합은 잘 사용되지 않습니다.
> 

---

### 세마포어와의 조합

> 세마포어는 공유자원에 접근할 수 있는 스레드의 개수를 제한하는 동기화 기법입니다.
이러한 특징을 지키기위해 세마포어는 단순 현재 몇개의 스레드가 접근할 수 있는지 제어만 할 뿐입니다.

하지만 조건변수는 특정 상태(조건의 충족성)을 체크하고 관리할 수 있는데, 이러한 세마포어와 조건변수의 특징을 합쳤을때 다음과 같은 우려점이 있습니다.

조건 변수의 사용을 통해 특정 조건이 만족될 때 스레드가 깨어나지만, 세마포어는 단순 카운팅 기법이기 때문에 세밀한 조건 처리가 어렵습니다. 

따라서 세마포어와의 조합도 잘 사용되지 않습니다.
> 

---

이렇게 다른 락 조합방식과 잘 사용되지 않는 이유에 대해서 알아보았는데요. 

그렇다면 왜 뮤텍스와 조건변수는 잘어울릴까요?

### 뮤텍스 + 조건변수

> 뮤텍스와 조건변수를 조합하여 사용하게 되면 스레드가 무한정 대기하지 않고 필요한 순간에 깨어나 작업을 실행할 수 있으므로 불필요하게 CPU를 낭비하지 않으며 높은 성능을 제공하게 됩니다. 

이러한 동작방식이 가능한 이유는 `조건 대기큐`와 `뮤텍스 대기큐`가 존재하기 때문에 가능합니다.

일단, 스레드는 특정 조건을 만족할 때 까지 조건 대기큐에 머무르게 됩니다. 이렇게 대기하다가 특정 조건이 만족된 경우 해당 스레드가 깨어나게되는데요. 이때, 해당 임계영역에 접근하게 됩니다. 

아쉽게도 이번 접근에서 뮤텍스락을 얻지 못한다면 뮤텍스 대기큐에서 다시 대기하게 됩니다. 이때 조건 대기큐로 다시 가지않는 이유는 조건은 이미 만족시켰고 임계영역에 대한 접근만 하면 되기 때문입니다.

하지만 운이 좋다면 깨어난 즉시 바로 임계영역에 접근하여 작업할 수 있겠죠. 이는 CPU를 필요한 순간에만 사용할 수 있으므로 CPU의 낭비가 매우 적고 빠른 작업처리를 할 수 있게 됩니다.

따라서 뮤텍스와 조건변수의 조합은 정석적이라고 할만큼 잘어울리는 방식입니다.
> 

# 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.

---

데드락이 발생하는 조건에는 4가지 필요충분 조건이 있습니다.

이러한 조건을 코프만 조건(Coffman condition)이라고 하는데요. 한번 알아보겠습니다.

### 상호배제

- 각 자원은 한번에 하나의 스레드에게만 할당

### 소유하면서 대기 (Hold & Wait)

- 스레드가 한 자원을 소유(lock)하면서 다른 자원을 기다림

### 강제 자원 반환 불가 (No Preemption)

- 스레드에게 할당된 자원을 강제로 뺏지 못함

### 환형 대기 (Circular Wait)

- 한 그룹의 스레드들에 대해, 각 스레드는 다른 스레드가 요청하는 자원을 소유하는 원형 고리

이 4가지 조건을 모두 충족시켜야만 데드락이 발생합니다.

하지만, 교착상태가 발생해선 안되겠죠? 어떻게 하면 데드락을 **예방**할 수 있을지에 대해 알아보겠습니다.

### 예방 (Prevention)

- 데드락 발생 여지를 차단하여 예방
- 데드락 4가지 조건 중 하나 이상의 조건이 성립하지 못하도록 시스템을 구성하는것

### 데드락 회피(Avoidance)

- 미래에 데드락으로 가지 않도록 회피하는 방식
- 자원 할당 시마다 미래의 데드락 가능성을 검사하여 데드락이 발생하지 않을 것이라고 **확신** 하는 경우에만 자원 할당 (banker’s algorithm)

### 데드락 감지 및 복구 (Detection And Recovery)

- 데드락을 감지하는 프로그램 구동하여 발견 하면 데드락 해제

### 데드락 무시

- 데드락이 없다고 단정하는 방식
- 사용자가 프로그램에 이상을 느끼면 재실행할 것을 기대하는 방식이다.
- 이는 현재 대부분의 운영체제에서 사용되는 방식이다.

# 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.

---

낙관적 락은 데이터 충돌이 거의 없을것을 기대하고 한 공유자원에 대해 여러 스레드가 접근할 수 있도록 하는 방식입니다.

기대만 할 뿐 실제 데이터 충돌이 발생한 경우 `롤백`과 `재실행`을 통해 동기화를 진행하게 됩니다.

따라서, 낙관적 락 방식은 데이터 충돌이 적은 작업에서 많이 사용되는 방식인데요. 만약 충돌이 빈번하게 발생하게 되는 환경에서의 낙관적 락의 성은 어떨까요?

나쁜점을 알아보기 전에 낙관적 락의 **장점**에 대해서 짚고 넘어가겠습니다.

> **데이터 경합이 거의 없는 환경에서 성능이 매우 뛰어나다.**
> 
> - **락을 사용하지 않기** 때문에, 락 사용으로 인한 오버헤드가 없다.

> **데이터 경합이 거의 없는 환경에서 병렬처리 효율 극대화**
> 
> - 여러 스레드가 동시에 공유자원에 접근을해서 작업을 할 수 있으므로

장점을 알아보았으니 충돌이 빈번한 상황에서 낙관적 락이 어떤 **단점**을 가지게 될지 보겠습니다.

> **롤백 비용 발생**
> 
> - 데이터 충돌이 일어난 경우 **롤백**을 필수로 해야하기 때문에, 롤백으로 인한 비용이 발생한다.

> **충돌시 성능 저하**
> 
> - 충돌이 발생하면 롤백과 더불어 작업을 재실행해야 하므로 비용이 많이 발생하며, 시스템 성능 저하로 이어진다.
> - 트랜잭션이 긴 작업일수록 충돌 가능성이 높아지게 됩니다.

# 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.

---

세마포어는 공유자원에 대해 접근할 수 있는 스레드의 개수를 제한할 수 있는 방식입니다.

이 방식은 뮤텍스와는 달리 접근한 스레드 모두가 세마포어를 해제할 수 있는 권한을 가지고 있습니다.

세마포어의 특징으로 인한 **장점**은 다음과 같은데요.

- **동시 접근 제어**
- **자원 낭비 방지**

이러한 특성 덕분에 `스레드 풀` 또는 `데이터베이스 커넥션 풀`에서 사용됩니다.

스레드 풀에서 어떤식으로 세마포어가 활용되는지 알아보도록 해봅시다!

### 스레드풀

> 스레드 풀은 작업을 실행할 스레드 개수를 제한하여 관리하는 기법입니다.
쉽게말해 미리 일정 개수의 스레드들을 만들어두고 이를 재활용하여 사용하는 방식입니다.
> 

스레드풀에서 세마포어가 사용되는데요. 스레드풀의 설명을 읽어보면 감이 딱 오지 않으신가요?

스레드풀에서는 **미리 만들어둘 스레드의 개수**를 지정하는데 이게 바로 세마포어에서 공유자원에 대해 접근할 수 있는 스레드의 개수를 제한하는 것과 같은 방식입니다.

동작방식은 다음과 같습니다.

1. **세마포어 초기화**
    - 최대 실행 가능한 스레드 개수만큼 세마포어 생성
2. **작업 실행 요청**
    - 작업 요청이 온 경우 **세마포어 값을 감소**하며 작업 진행
3. **작업 완료후 반환**
    - 작업이 완료되면 **세마포어 값을 증가**

이러한 동작방식덕에 계속 스레드가 생성되는것을 방지할 수 있으며, CPU 자원의 효율성을 높일 수 있습니다.

# JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?

---

JS의 경우 기본적으로 싱글스레드 기반의 이벤트 루프모델을 사용하고 있습니다.

이때문에 멀티스레드 환경에서 발생할 수 있는 전통적인 동시성문제인 데드락, 레이스 컨디션등이 직접적으로 발생하진 않습니다.

다만, 비동기 작업과 상태관리를 결합하여 사용할 경우 동시성 문제를 고려해야 합니다.

### 비동기 작업과 동시성 문제

JS에서는 Promise 또는 async/await 을 이용하여 비동기 처리를 진행합니다.

이때, **비동기 작업의 실행 순서가 보장되지 않을 경우** 상태가 꼬일 수 있습니다.

만약 `async`만 사용해서 비동기 처리를 한후 `await`을 사용하지 않아서 비동기 작업의 순서가 보장되지 않는 경우 해당 문제가 발생하 수 있습니다.

---

### 상태관리와 동시성 문제

React나 Vue를 사용해보신 분들이라면 상태관리에 대해서 자주 들으셨을겁니다.

`useState`, `useEffect`, `Redux`와 같은 상태관리 라이브러리에서 상태를 관리하게 되는데 이때 상태가 비동기적으로 업데이트 되는 순간을 조심해야 합니다.

만약 useState를 비동기적으로 사용한다고 했을때 동시성 문제가 발생할 수 있습니다.

```jsx
function Counter() {
    const [count, setCount] = useState(0);

    function handleIncrement() {
        setTimeout(() => {
            setCount(count + 1);
        }, 1000);
    }

    return <button onClick={handleIncrement}>Click {count}</button>;
}
```

해당 코드를 보게되면 setCount를 이용해서 count값에 변화를 주는것을 볼 수 있습니다.

이때 사용자가 무수히 많은 클릭이벤트를 발생시키는 상황에서 Race Condition 문제가 발생할 수 있습니다.

setCount의 호출시점에 count 값이 최신 상태인지 보장이 안되기 때문입니다.

이를 해결하기 위해서는 아래와같이 함수형을 이용하면 됩니다.

```jsx
setCount(count + 1); => setCount((precCnt) => precCnt + 1);
// prevCnt의 경우 React가 자동으로 최신 상태를 전달하게 됩니다.
```
# 회고
# 💪 K (Keep) 💪
- 딥다이브는 재밌어~~~~
  
# 😫 P (Problem) 😫
- 

# 🫵 T (Try) 🫵
- 
