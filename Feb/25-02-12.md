# 💬 데일리 스크럼 💬
- 오늘 배운거 복습하기
- 2주차 과제 피드백 반영하기
***
# 🧑🏻‍💻 학습한 내용 🧑🏻‍💻
# 클라이언트 - 서버

> 클라이언트 : 요청을 하는 주체
> 

> 서버 : 요청에 대한 응답을 하는 주체
> 

---

클라이언트와 서버는 많이 들어봤을 것이다.

클라이언트는 요청을 하는 주체로서 **고객**, **앱**, **웹**등이 될 수 있다.

서버는 응답을 하는 주체로서 **웹서버**등이 있다.

# DNS

> DNS : 사용자친화 주소를 ip로 변환하는 시스템
> 

---

DNS는 Domain Name System으로 사용자 친화적인 도메인 주소를 ip로 변환하는 역할을 합니다.

예를 들어 `www.naver.com` 을 크롬에 검색해보면 바로 네이버로 연결되는 것을 볼 수 있는데요.

실제 네이버의 IP를 얻어와 사이트에 접근하게 되는것입니다.

++) [www.naver.com](http://www.naver.com) 의 ip 주소를 얻어보려면 `nslookup` 명령어를 실행해보면 됩니다. 

![image.png](attachment:aa94093e-3378-4f9b-a6aa-cb7a5998e249:image.png)

이런 정보를 통해 [`naver.com`](http://naver.com) 이 현재 `61.41.153.2` ip주소를 사용중인것을 알 수 있습니다.

# OSI 7계층

> OSI 7계층 : 네트워크 통신과정을 7개의 Layer로 나눈것
> 

---

OSI는 Open Systems Interconnections의 약어입니다. 

특히 OSI 7계층은 국제표준기구(ISO)에서 정의한 네트워크 통신의 참조 모델인데요. 

네트워크 통신이 어떻게 이루어지는지를 설명하는 7계층 구조의 표준 모델입니다.

7계층은 다음과 같이 이루어져 있습니다.

### 1계층 : 물리 계층

> 해당 계층에서는 통신 케이블을 통해 데이터를 전송한다.

해당 통신에서 사용되는 통신단위는 **비트**이다.

해당 계층에서는 단지 데이터만 전달할 뿐 데이터의 에러가 있는지는 신경쓰지 않는다.

여기에 해당되는 장비는 `케이블`, `리피터`, `허브`등이 있다.
> 

### 2계층 : 데이터 링크계층

> 해당 계층은 물리계층을 통해 송수신 되는 정보의 오류와 흐름을 관리한다.
이를 통해 안전한 정보의 전달을 수행할 수 있도록 돕는 목적을 가지고있다.
따라서, 오류 탐지, 재전송등의 기능을 가지고있다.

해당 계층에서는 **맥(MAC) 주소**라는 물리적 주소를 가지고 통신을 하게된다.

해당 계층의 단위는 **프레임**이라 불리며, 해당 장비에는 `브리지`, `스위치` 등이 있다.
> 

### 3계층 : 네트워크 계층

> 해당 계층의 목적은 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능 → 즉 **라우팅**이다.

네트워크 계층에서는 라우팅, 흐름제어, 세그먼테이션, 오류 제어, 인터네트워킹등을 수행한다.

해당 계층의 프로토콜에는 IP, ICMP, ARP등이 있다.
또한 장비로는 `라우터`, `L3 스위치` 등이 있다.
> 

### 4계층 : 전송 계층 (Transport)

> 해당 계층의 목적은 **데이터의 신뢰성을 보장**하여 상위 계층에서 안심하고 데이터를 쓸 수 있도록함에 있다.

해당 계층의 대표적인 프로토콜로는 **TCP/ UDP**가 있으며, 이 프로토콜을 통해 데이터의 신뢰성을 보장하게 된다.

해당 계층의 주요 장비로는 `로드밸런서` 등이 있다.
> 

### 5계층 : 세션 계층

> 해당 계층의 목적은 통신 세션을 설정, 유지, 종료하는데 있다.

해당 계층에서는 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공하는데,
여기에는 동시 송수신 방식(duplex), 반이중 방식(falt-duplex), 전이중 방식(full duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 재시작 과정등을 수행한다.

해당 계층의 대표적 프로토콜로는 **SSH**, **RPC**등이 있다.

해당 계층의 장비로는 `방화벽` 등이 있다.
> 

### 6계층 : 표현계층 (Presentation)

> 해당 계층의 목적은 **데이터의 형식 변환**, **암호화** 및 **압축**을 담당하여 서로 다른 시스템간의 데이터 호환성을 보장하는데 있다.

해당 계층의 주요 프로토콜에는 **SSL**, **TLS**, **JPEG** 등이 있다.

해당 계층의 주요 장비로는 `미디어 서버`, `SSL/TLS 가속기` 등이 있다.
> 

### 7계층 : 애플리케이션 계층

> 네트워크 통신에서의 최종 목적지 계층이다.

해당 계층에서는 응용 프로세스와 직접 관계되어 일반적인 응용서비스를 수행한다.

해당 계층의 주요 프로토콜에는 **HTTP**, **FTP**, **SMTP**, **POP3**, **IMAP** 등이 있다.

주요 장비로는 `웹 서버`, `메일 서버`, `DNS 서버`, `FTP 서버`등이 있다.
> 

OSI 7계층의 대안 모델은 TPC/IP 모델이 있다.

# TCP

> TCP : 순서를 보장하며 신뢰성있는 연결을 제공하는 프로토콜
> 

---

TCP는 전송 제어 프로토콜로 두 호스트를 연결하고 데이터 스트림을 교환하게 해주는 역할을 수행합니다.

TCP에는 여러 특징이 존재합니다.

- 보내진 데이터와 패킷의 순서 보장
- 에러 방지 보장

이러한 특징을 이용하여 TCP는 패킷의 신뢰성을 보장하게 됩니다.

### 3way-handshake

> TCP는 3way-handshake 라는 기법을 이용하여 두 호스트의 연결을 진행하게 됩니다.

이 과정을 통해 두 호스트 모두 데이터 송신 및 수신 준비가 완료됨을 알게됩니다.

이 과정은 다음과 같은 순서로 진행됩니다.

1. Client가 Server에게 연결 요청하는 `SYN` 패킷 전송
    - 이때, 시퀀스 번호를 함께 보냅니다.
2. Server는 Client의 `요청`(SYN)에 대한 `응답`(ACK)를 해당 `시퀀스번호 + 1` 한 값을 응답해줍니다.
    동시에 Client에게 `요청` (SYN )를 시퀀스번호와 함께 전송합니다.
3. Client는 서버의 SYN 요청에대한 `ACK`와 서버가 정한 `시퀀스번호 + 1` 한 값으로 응답해줍니다.
> 

### 흐름제어, 혼잡제어

---

TCP 는 신뢰성있는 전송을 위해 때로는 흐름제어와 혼잡제어를 하게 됩니다.

- 흐름제어
    
    > 만약 데이터를 보내는 속도보다 쓰는 속보가 빠르면 어떻게 될까요?
    
    이 경우에 데이터가 전송되지 못하고 Loss 되는 경우가 꽤 있을겁니다.
    
    따라서 TCP에서는 이러한 상황을 방지하기 위해 `Receiver`쪽에서 헤더의 `recieve window`를 통해 `Sender`에게 이정도의 데이터만 달라고 요청하게됩니다!
    
    이를 통해 Sender는 Receiver에게 receive window 값 이하의 데이터만 전송해줍니다. 
    따라서 Receiver에서 감당가능한 데이터를 전송하게됩니다.
    
    이 상황은 주로 **일대일 통신**에서 발생하게 됩니다.
    > 
    > 
    > ![image.png](attachment:95fbd669-f75f-454c-910d-3e21a4b4cf9d:image.png)
    > 
- 혼잡제어
    
    > 만약 네트워크에서 감당하지 못할만큼 다수의 Sender가 너무 빠르게 데이터를 전송한다면 어떻게 될까요?
    
    이런 상황자체가 혼잡 그자체일겁니다.
    
    현재 상황이 혼잡한지를 판단하는 두가지 조건이 있는데요. 다음과 같습니다.
    1. `Packet Loss`가 발생했는가?
    2. `Long Delay`가 발생했는가?
    
    이 두가지 상황이 모두 발생하게 된 경우 혼잡하다고 판단하게 됩니다.
    
    TCP에서는 이런 혼잡한 상황을 위해서 `AIMD` 방식 또는 `Slow Start` 방식을 사용하게 됩니다.
    CUBIC, Delay-based 를 활용한 혼잡 제어 방식도 있습니다.
    
    AIMD는 Sender가 packet을 보낼 때, **packet loss가 발생하기 전**까지 `AI`를 하다가 **loss가 발생하게 되면** `sending rate`를 `MD` 하며혼잡제어를 하게 됩니다.
    
    - Additive Increase (점진적 증가)
    - Multiplicative Decrease (1/2 감소)
    > 

### (선택) 슬라이딩 윈도우

---

**슬라이딩 윈도우**는 연속된 데이터에서 **일정 크기(윈도우)**를 정해놓고 윈도우를 오른쪽으로 한칸씩 움직이며 데이터를 처리하는 기법입니다.

![image.png](attachment:973ea6af-20e6-4737-9da8-275588574090:image.png)

알고리즘에서 많이 접하는 단어일텐데요. 그 작동방식과 일치합니다.

TCP에서는 슬라이딩 윈도우를 이용하여 순차적인 패킷을 전송을 할 수 있게되었습니다.

이 방식의 **장점**은 다음과 같습니다.

- 패킷의 순서를 유지하며 전송할 수 있음
- 패킷이 잘못된 경우 재전송을 통해 신뢰성을 유지할 수 있음

### (선택) slow start

---

Slow Start는 TCP에서 혼잡제어를 하는 방식중 하나입니다.

Slow Start는 이름과 같이 처음에 천천히 시작하게됩니다.

천천히 시작한다는 말은 무슨 뜻일까요?

![image.png](attachment:0b7ba93d-6e93-469d-8bf0-8bb23f223608:image.png)

이 방식은 `rate`를 **1로 시작**해서 **Data Loss가 발생하기 전**까지 **2배씩 증가**시켜 **최대 전송률**을 찾는 방식입니다.

# UDP

> UDP : 빠른 데이터 전송을 위한 비신뢰성 비연결성 프로토콜
> 

---

UDP(User Datagram Protocol)는  TCP의 3way-handshaking과 같은 두 호스트의 연결을 하지 않습니다.

따라서 각각의 UDP segments는 독립적으로 처리되게 되며 이로인해 다음과 같은 상황이 발생할 수 있습니다.

- Segment Loss
- 데이터 순서 보장 안됨

또한 UDP는 다음과 같은 특징이 있습니다.

- TCP에 비해 헤더 크기가 작다. (TCP : 20byte , UDP : 8byte)
- 혼잡제어를 하지 않는다.

이러한 상황이 발생하더라도 **사전 연결을 하지 않기때문**에 **빠르게 데이터 송수신**을 진행할 수 있다는 장점이 있습니다.

그렇기 때문에 UDP는 다음과 같은 상황에 사용되게 됩니다.

- 스트리밍 서비스
- SNMP
- HTTP / 3

UDP가 신뢰성을 보장하지 않는다고 했는데요. 만약 신뢰성을 더하고싶다면 **Application Layer**에서 진행하면 됩니다.

++) UDP에서도 에러를 감지할 수 있습니다. 이를 위해 **UDP checksum**을 이용하게 되는데요. 이는 에러만 감지할 뿐 복구하지는 않습니다.

# CDN

> CDN : 사용자에게 빠르고 효율적인 컨텐츠 전송을 위해 분산된 서버 네트워크
> 

---

CDN는 Contents Delivery Network로 전세계에 분산된 네트워크를 말합니다. 

CDN의 목적은 다양한 사용자에게 빠르고 효율적으로 컨텐츠를 전송하기 위해 탄생했습니다.

CDN을 사용하면 다음과같은 **장점**이 있습니다.

- 웹사이트 성능 최적화
    - 웹사이트의 트래픽을 한곳이 아닌 여러곳으로 분산시켜 부하를 방지한다.
- 정적, 동적 컨텐츠 전송
    - 정적 컨텐츠와 동적 컨텐츠 모두 지원합니다.

AWS에서 많이 사용되는 서비스인 **CloudFront**도 CDN 서비스중 하나입니다.

# HTTP / HTTPS

> HTTP : 클라이언트와 서버사이의 통신을 위해 사용되는 통신 프로토콜
> 

> HTTPS : HTTP에 Secure 기능을 넣어 보안성을 추가한 통신 프로토콜
> 

---

### HTTP Method 요청의 종류

---

- `GET`
    
    > 데이터의 **조회**를 할 때 사용하는 메서드입니다.
    > 
- `HEAD`
    
    > GET과 **동일한 응답**을 요구하지만 **응답 본문을 포함하지 않는** 메서드입니다.
    > 
- `POST`
    
    > 데이터를 서버에 **새로 생성**할 때 사용하는 메서드입니다.
    > 
- `PUT`
    
    > 서버에 존재하는 데이터를 **수정**하거나 존재하지 않는다면 **생성**하는 메서드입니다.
    > 
- `DELETE`
    
    > 서버에 존재하는 데이터를 **삭제**할 때 사용하는 메서드입니다.
    > 
- `PATCH`
    
    > 서버에 존재하는 데이터의 **일부를 수정**할 때 사용하는 메서드입니다.
    > 

### (선택) HTTP Header/Body 구조

---

![image.png](attachment:7fb24342-0cec-46d0-bd2a-1078569ece40:image.png)

이건 HTTP 1.1 의 헤더와 바디의 구조입니다.

**헤더**는 요청과 함께 **추가적인 정보**를 전달하는 필드입니다. 

- **Host** : 요청 대상 서버의 도메인
- **User**-**Agent** : 클라이언트의 정보
- **Accept** : 서버가 응답할 수 있는 컨텐츠 유형
- **Content**-**Type** : 요청 본문의 데이터 타입
- **Content**-**Length** : 본문의 크기 (바이트 단위)

**바디**는 요청과 함께 보낸 데이터가 들어있습니다.

- **JSON** 형태의 데이터가 있을 수 있습니다.

### (선택) HTTP 상태 코드

---

HTTP에는 상태 코드가 존재합니다.

상태코드는 요청에 대한 응답이 성공했는지, 오류가 발생했는지를 숫자로 나타내는 코드입니다.

간단하게 알아보면 다음과같은 종류가 있습니다.

|  | 설명 |
| --- | --- |
| `1xx` (정보) | 요청을 받았으며, 처리중 (거의 사용되지 않음) |
| `2xx` (성공) | 요청이 정상적으로 처리됨 |
| `3xx` (리다이렉션) | 요청한 리소스가 이동되었음 (다른 URL로 리다이렉션) |
| `4xx` (클라이언트 오류) | 클라이언트에서 문제 발생 |
| `5xx` (서버 오류) | 서버에서 요청을 처리하던 중 오류 발생 |

### 2xx (성공) 자주 쓰이는 상태코드

|  | 의미 |
| --- | --- |
| 201 Created | 요청이 성공적으로 처리되었으며, 새로운 리소스가 생성됨  |
| 204 No Content | 요청이 성공했지만 반환할 데이터 없음 |

### 3xx (성공) 자주 쓰이는 상태코드

|  | 의미 |
| --- | --- |
| 301 Moved Permanently | 요청한 리소스가 영구적으로 다른 URL 로 이동됨 |
| 302 Found | 요청한 리소스가 임시로 다른 URL로 이동됨 |
| 304 Not Modified | 캐싱된 데이터를 사용하도록 유도 |

### 4xx (성공) 자주 쓰이는 상태코드

|  | 의미 |
| --- | --- |
| 400 Bad Request | 잘못된 요청 |
| 401 Unauthorized | 인증 필요 |
| 403 Forbidden | 요청이 서버에서 거부됨 (권한 부족) |
| 404 Not Found | 요청한 리소스를 찾을 수 없음 |
| 405 Method Not Allowed | 해당 URL에서 HTTP 메서드 사용 불가능 |

### 5xx (성공) 자주 쓰이는 상태코드

|  | 의미 |
| --- | --- |
| 500 Internal Server Error | 서버 내부 오류 |
| 502 Bad Gateway | 게이트웨이 서버 오류 |
| 503 Service Unavailable | 서버 과부하 또는 점검중 |
| 504 Gateway Timeout | 게이트웨이 서버에서 응답 시간 초과 |

# TLS / SSL

> TLS : 데이터의 암호화와 무결성을 보장하는 보안 소켓 계층
> 

> SSL : 데이터 암호화를 하는 보안 소켓 계층
> 

---

**SSL/TLS**는 자주 들어본 단어일겁니다.

HTTP에서도 SSL/TLS가 적용되면 HTTPS가 될 수 있습니다.

이렇듯 SSL/TLS는 인터넷에서 보안과 관련된 기술입니다. SSL이 먼저 세상에 나타났고 그 이후 SSL을 더욱 견고하고 안전하게 만든게 TLS입니다.

❓ 그러면 SSL은 더이상 안써도 되지 않나요? 

❗️ 맞습니다. SSL은 너무 오래되어 보안이 취약하다는 단점이 있습니다. 하지만 인터넷 초창기부터 존재했기 때문에 다양한 환경과 호환성이 좋다는 장점이 있습니다.

TLS는 보안측면에서의 뛰어난 성능을 자랑합니다. 하지만 SSL보다 까다로운 설정이 단점으로 존재합니다.

# (선택) QUIC, HTTP 버전별 특징 비교, HTTP/2 Multiplexing

> QUIC : 구글이 개발한 전송 계층 프로토콜
> 

> HTTP/2 Multiplexing : 하나의 TCP connection 상에서 여러개의 request, response을 동시에 처리하는 기술
> 

---

### QUIC

QUIC은 구글이 개발한 새로운 전송 계층 프로토콜입니다. TPC의 지연 문제를 해결하고 보안을 강화하기 위해 만들어졌습니다.

QUIC은 UDP 프로토콜 위에 구현된 기술입니다. 다만, TCP의 흐름제어, 오류제어, 혼잡 제어와 같은 기능이 모두 구현되어 있어서 신뢰성을 챙길 수 있습니다.

QUIC은 기존의 TCP + TLS + HTTP/2 기능을 통합해서 더 빠르고 안정적인 연결을 제공하게 됩니다.

QUIC은 장점은 다음과 같습니다.

- **연결 지연 최소화**
    - TCP의 3-way handshake를 사용하지 않아 더 빠른 연결 설정가능
- **멀티 플렉싱 지원**
    - TCP + HTTP/2 는 HLB 문제가 발생시 뒤의 요청또한 모두 지원되는데 **QUIC은 각 데이터 스트림을 독립적으로 처리**하기 때문에 하나의 요청이 지연되어도 다른 요청이 영향을 받지 않는다.
- **빠른 회복 (Packet Loss Recovery)**
    - TCP는 패킷 손실시 전체 연결이 지연될 수 있지만 QUIC은 손실된 스트림만 재전송하기 때문에 빠른 회복이 가능하다.

이러한 장점덕에 QUIC은 HTTP/3 에서 전송 계층 프로토콜로 채택되었습니다.

---

### 버전별 HTTP

|  | HTTP/1.0 | HTTP/1.1 | HTTP/2 | HTTP/3 |
| --- | --- | --- | --- | --- |
| 출시 연도 | 1996년 | 1997년 | 2015 | 2022 |
| 전송 방식 | 단일 연결 | 지속적 연결 | 멀티 플렉싱 | QUIC 기반 멀티플렉싱 |
| 연결 방식 | 요청-응답 마다 새 연결 생성 | 지속적 연결 | 하나의 연결에서 여러 요청 처리 | UDP 기반 연결 |
| Head-Of-Line Blocking | 존재 | 존재 | 일반 존재 | QUIC이라 없음 |
| 멀티플렉싱 | 지원 안함 | 지원 안함 | 지원 | 지원 |
| 압축 | 지원 안함 | 지원 안함 | HPACK | QPACK |
| 보안 | 필요 없음 | 필요 시 적용 | 기본 지원 (TLS 1.2) | 기본 지원 (TLS 1.3) |
| 속도 개선 | 낮음 | 중간 | 높음 | 매우 빠름 |
| 기반 프로토콜  | TCP | TCP | TCP | UDP (QUIC) |

---

### HTTP/2 멀티플렉싱

멀티플렉싱은 하나의 TCP연결에서 여러개의 요청, 응답을 동시에 처리하는 기술입니다.

이 기술의 탄생목적은 이전 HTTP 버전에서의 **HLB 문제를 없애고자** 개발되었습니다. 즉, 이전 요청의 지연때문에 전체 연결의 성능이 떨어지는 문제를 해결하고자 탄생했습니다.

이를 구현하기위해 각 요청과 응답에 대해 개별 스트림을 갖추고, 프레임 단위로 처리하며 동시에 요청과 응답을 처리하게 하였습니다.

동작방식은 다음과 같습니다.

1. 클라이언트가 여러 개의 요청(A, B, C)을 동시에 보냄
2. 서버는 각 요청을 **독립적인 스트림**으로 구분하여 처리
3. 요청 A가 지연되더라도, 요청 B와 C는 영향을 받지 않고 응답을 받을 수 있음.

# 대칭키, 비대칭키 암호화 방식

> (Private Key) 대칭키 : 암호화 및 복호화에 하나의 키를 사용하는 방식
> 

> (Public Key) 비대칭키 : 암호화 및 복호화에 공개키, 개인키 총 두가지의 키를 사용하는 방식
> 

---

### 대칭키 암호화 방식

대칭키는 암호화와 복호화에 하나의 키를 사용하는 방식입니다.

즉, 데이터를 암호화할때와 복호화할 때 똑같은 키를 사용하게됩니다. 

해당 방식의 장점은 데이터의 암복호화에 걸리는 시간이 짧다는 것입니다. 암복호화에 하나의 키만 사용하기 때문에 가능한 일입니다.

하지만 송신자와 수신자 모두 해당 키를 가지고있어야 하므로 **키를 분배하는게 어려우며** **많은 수의 키가 필요하다**는 문제점이 있습니다.

### 비대칭키 암호화 방식

비대칭키는 암복호화에 개인키, 공개키를 두가지 키를 사용하는 방식입니다.

여기서는 2가지의 경우가 있습니다.

- **개인키로 암호화 + 공개키로 복호화**
    
    > 이 방식은 왜 쓰지? 라는 의문이 들게 됩니다.
    
    왜냐하면 공개키는 아무나 가질 수 있는 키이기 때문입니다.
    
    하지만 이 방식은 그러한 특징때문에 사용되게 됩니다.
    
    다들 ‘전자서명’을 많이 들어보셨을겁니다. 이 방식은 전자서명에서 많이 사용되게 되는데요.
    
    따라서, 이 방식은 아무나 데이터를 열어봐도 상관이 없습니다. 이 방식의 목적은 
    **유저A가 암호화했다는 정보**만 얻으면 그만입니다. 즉, 데이터의 암호화는 중요치 않습니다.
    > 
- **공개키로 암호화 + 개인키로 복호화**
    
    > 해당 방식은 유저 B가 유저 A에게 데이터를 보낼 때 사용됩니다.
    
    즉, 유저 A의 공개키를 통해 A에게 보낼 데이터를 암호화하고 전송하게됩니다.
    
    그렇다면 이 데이터는 A의 개인키로밖에 풀지 못하게되니 A를 제외한 아무도 데이터를 볼 수 없습니다.
    
    해당 방식의 목적은 데이터를 받은 **수신자만 데이터를 볼 수 있도록하기 위함**입니다.
    > 

# HTTP Cache

> HTTP Cache : 웹 리소스를 브라우저 또는 서버에 캐싱해놓는 방식
> 

---

**HTTP Cache**는 텍스트, 사진, 영상과 같은 웹 리소스를 사용자의 브라우저 또는 서버에 캐싱해놓는 방식입니다.

캐싱을 적용하며 다음과 같은 **장점**을 얻을 수 있습니다.

- **성능 최적화**
    - 로딩 시간 단축으로 인한 성능 최적화 및 서버 부하 감소
- **비용절감**
    - 대용량 파일의 경우 캐싱을 적용할 경우 서버부하가 적어져 네트워크 비용 감소
- **UX 향상**
    - 로딩시간 단축으로 인한 사용자 경험 향상

HTTP Cache에는 다음과 같은 종류가 있습니다.

- **Private Cache (Browser Cache)**
    
    > Private Cache는 사용자의 브라우저내에 저장된 개인화된 캐시입니다.
    
    주로 사용자가 **최근에 방문한 웹사이트의 리소스를 캐싱**해둡니다.
    > 
- **Shared Cache**
    
    > Shared Cache는 여러 사용자가 접근하는 **공용 자원에 대해 효율적 배포를 위한 캐싱**을 뜻합니다.
    
    CDN 또는 프록시서버에 리소스가 저장되게 됩니다.
    > 
- **Proxy Cache**
    
    > Proxy Cache는 ISP 또는 대규모 네트워크에서 생성된 웹 리소스의 사본을 저장하고 후 요청시 빠르게 제공하는 방식입니다.
    
    ISP 또는 네트워크 프록시서버에 저장됩니다.
    > 
- **Managed Cache**
    
    > Managed Cache는 특정 애플리케이션 또는 서버에서 관리하는 캐싱을 뜻합니다.
    
    이때, 데이터의 일관성을 보장받기위한 캐시 관리 정책을 가지고있어야 합니다.
    > 
    

Managed Cache → Private Cache 방향으로 갈수록 개인화된 리소스를 저장하게 됩니다.

# API

> API : 요청의 접점입니다.
> 

---

API는 요청의 접점이라고 생각하시면 편합니다.

예시로 들어보자면 여러분들이 현재 날씨를 보여주는 서비스를 개발하려고합니다.

그러면 날씨를 제공해주는 서비스에서 제공받는게 편하겠죠?

이때 날씨 제공 서비스에서 API를 제공해준다면 저희는 이 API를 가지고 편리하게 날씨를 제공받을 수 있게 됩니다.

즉, 클라이언트에서 서버 또는 서버에서 서버로 까지 다양한 서비스들 사이의 상호작용을 가능하게 하는것이 API라고 보시면 편합니다.

# API Gateway

> API Gateway : API 요청을 중개하고 관리하는 역할을 하는 서비스
> 

---

API Gateway는 클라이언트에서 서버로 날리는 API요청을 관리하는 서비스입니다.

만약 API Gateway가 없다면 클라이언트에서 서버의 API를 직접 호출해야합니다. 이렇게 될 경우 서비스별로 별도 요청을 보내야하며, 보안문제, 복잡한 로직등의 문제점이 발생할 수 있습니다.

이러한 문제점을 해결하고자 API Gateway가 쓰이기 시작하였습니다.

API Gateway를 통해 클라이언트는 요청을 Gateway에게 하면 되고 Gateway에서 적절한 서버로 요청을 전달하게 됩니다.

# REST 아키텍처 스타일

> REST 아키텍처 스타일 : REST한 설계를 위한 지침서입니다.
> 

---

### **REST 아키텍처 스타일**

- **Uniform Interface**
    - **모든 API가 일관된 방식으로 통신**하도록 해서 사용하는데 있어 단순성과 상호 운용성을 보장해야 합니다.
    - 예를 들어, 웹 사이트에서 모든 게시글을 보는 URL은 ‘/posts’ 로 설정하고, 특정 게시글을 보는 URL은 ‘/post/{postId}’ 로 설정해야합니다.
- **Client-Server**
    - **클라이언트와 서버가 독립적으로 구분**되어 있고, 각각의 개발 확장이 편리하며, 사용자 인터페이스와 데이터 저장소가 분리 되어야 한다는 규칙입니다.
    - 예를 들어, 웹사이트에서 사용자가 게시글을 상황에 사용자의 브라우저(클라이언트)는 글 작성과 관련된 인터페이스만 제공하고, 실제 데이터 처리와 저장은 웹 서버(서버)에서 이루어집니다.
    클라이언트와 서버가 명확히 분리되어 있어, 사용자 인터페이스 변경 없이도 서버 측 기능을 업데이트할 수 있습니다.
- **Stateless**
    - **서버는 클라이언트의 상태 정보를 저장하지 않아야 한다는 규칙입니다.**
    - 예를 들어, 온라인 쇼핑몰에서 장바구니에 상품을 추가할 때마다 사용자의 세션 정보 없이 사용자 ID와 상품 정보만 서버로 전송합니다. 서버는 이 정보만으로 요청을 처리합니다.
- **Cacheable**
    - **응답은 캐싱이 가능하도록 명시** 되어야 합니다.
    - 예를 들어, 뉴스 사이트에서 오늘의 뉴스 목록을 사용자의 브라우저에 임시 저장하여, 같은 요청이 있을 때 서버가 아닌 캐시에서 바로 정보를 가져옵니다.
- **Layered System**
    - **클라이언트는 서버가 단일 서버인지 다충 계층을 통해 데이터를 전달하는 중계서버를 거치는 지 알 수 없어야 합니다**.
    - 예를 들어, 사용자가 메시지를 보낼 때, 직접 메시지를 위한 서버에 접근하는 것이 아니라 보안을 위한 중계 서버를 거쳐 메시지가 전송됩니다. **사용자는 이러한 중계 과정을 모릅니다.**
- **Self-Descriptiveness**
    - **메세지 자체가 충분한 정보를 담고 있어**, 클라이언트가 어떻게 처리해야 할 지를 알 수 있어야 합니다.
    - 예를 들어, API에서 날씨 정보를 요청할 때, 응답으로 **`{"temperature": 25, "condition": "Sunny"}`** 같이 자체적으로 정보를 잘 설명하는 JSON을 반환합니다.
    이로 인해 개발자는 응답을 보고 바로 날씨 정보를 어떻게 처리할지 알 수 있습니다.

결론적으로 REST는 소프트웨어 아키텍처 스타일 중 하나인 것이고, API는 응용 프로그램 인터페이스 입니다.

즉, REST API의 고유 명사는 “REST 아키텍처 스타일을 따르는 응용 프로그램 인터페이스” 입니다.

# REST API

> REST API : REST 아키텍처 스타일을 따르는 API
> 

---

REST API는 REST 아키텍처 스타일을 따르는 API 입니다.

RESTFUL API 와 REST API의 차이점은 다음과 같습니다.

- REST API는 REST 아키텍처 스타일을 따르는 API들을 폭넓게 지칭한 것입니다.
- RESTFUL API는 REST 아키텍처 스타일을 엄격하게 따른 API 를 말합니다.

REST API에는 다음과 같은 사용방법이 존재합니다.

- **URI는 정보의 자원을 표현해야 한다.**
- **자원의 행위는 HTTP 메소드로 나타낸다.**
- **슬래시(/)는 계층 관계를 나타낼 때 사용한다.**
- **소문자를 사용한다.**
- **밑줄(_)은 사용하지 않고 하이픈(-)을 사용한다.**
- **확장자(.txt, .png 등)를 사용하지 않는다.**
- **URI의 마지막에 슬래시(/)를 포함하지 않는다.**

위의 사용방법을 모두 지킨다고 RESTFUL하다고 하진 않습니다.

하지만, 이러한 규칙을 지키고 API를 설계하게 된다면 여러 개발자들 간에 일관된 통신방식을 갖출 수 있을것입니다.

# TCP 프로토콜이 어떻게 신뢰성을 보장하는지 설명해주세요(or 신뢰성 보장을 위해 사용하는 매커니즘들을 설명해주세요)

---

TCP 프로토콜은 신뢰성있는 데이터의 송수신을 보장합니다.

이러한 신뢰성을 어떻게 챙길 수 있을까요?

### 3-way Handshake

> TCP에서는 두 호스트간의 연결을 3-way Handshake를 통해 진행하게 됩니다.

이는 두 호스트가 서로 데이터를 송수신할 준비가 되었는지 체크하고 모두 완료된 경우 연결을 완료하게 되는데요. 이를 통해서 신뢰할 수 있는 연결을 설정할 수 있습니다.
> 

---

### 데이터 세그먼트 & 시퀀스번호

> TCP에서는 연속된 데이터를 **일정 크기(윈도우)**를 정해 순차적으로 데이터를 전송하게 됩니다.

이는 슬라이딩 윈도우 기법인데요. 이를 통해서 **데이터(패킷)의 순서를 지키며 데이터를 송신**할 수 있게 됩니다.
> 

---

### 흐름제어 & 혼잡제어

---

> TCP에서는 흐름제어와 혼잡제어를 하게됩니다.

송수신 관계가 일대일 인 경우 흐름제어를 통해 두 호스트 사이의 데이터 송수신 속도를 관리하게 되며 
다대일 관계의 경우 혼잡제어를 통해 네트워크 상에서의 혼잡도를 관리하게 됩니다. 

이를 통해 데이터의 Loss를 최대한 방지하여 신뢰성있게 데이터를 전송하게 됩니다.
> 

---

### 오류검출 & 재전송

> TCP에서는 송신자가 보낸 패킷에 오류가 없는지 Checksum의 계산을 통해 판별하게 됩니다.

만약, Checksum 값에 문제가 있다면 패킷에 오류가 있다는것으로 판별하고 **재전송**을 요청하게 됩니다.
> 

# TCP와 UDP의 차이점을 설명해주세요.

---

TCP와 UDP의 가장 큰 차이점은 **신뢰성을 제공하느냐 여부**입니다.

**TCP**는 **3-Way Handshake**를 통해 **연결을 맺고**, **오류 검출 및 재전송, 시퀀스 번호를 통한 데이터 순서 보장** 등의 메커니즘을 사용하여 **데이터의 신뢰성을 보장**합니다.

반면 **UDP**는 **별도의 연결 설정 없이 즉시 데이터를 전송**하며, **오류 검출은 하지만 재전송을 요구하지 않고**, 데이터가 **순서에 상관없이 도착할 수 있는 특징**을 가지고 있습니다.

즉, 이러한 특징에 기반하여 **TCP는 신뢰성이 필요한 환경**에서 사용되고 **UDP는 빠른 전송이 중요한 환경**에서 사용됩니다.

# 3way-handshake의 과정에 대해서 설명해주세요(or 왜 필요한건지 설명해주세요)

---

### 3way-handshake

> TCP는 3way-handshake 라는 기법을 이용하여 두 호스트의 연결을 진행하게 됩니다.

이 과정을 통해 두 호스트 모두 데이터 송신 및 수신 준비가 완료됨을 알게됩니다.

이 과정은 다음과 같은 순서로 진행됩니다.

1. Client가 Server에게 연결 요청하는 `SYN` 패킷 전송
    - 이때, 시퀀스 번호를 함께 보냅니다.
2. Server는 Client의 `요청`(SYN)에 대한 `응답`(ACK)를 해당 `시퀀스번호 + 1` 한 값을 응답해줍니다.
    동시에 Client에게 `요청` (SYN )를 시퀀스번호와 함께 전송합니다.
3. Client는 서버의 SYN 요청에대한 `ACK`와 서버가 정한 `시퀀스번호 + 1` 한 값으로 응답해줍니다.
> 

앞서 3way-handshake의 동작방식을 알아보았는데요. 그렇다면 이런 과정은 왜 필요한걸까요?

결론부터 말하자면 **TCP는 신뢰성을 제공하는 연결형 프로토콜**이기 때문입니다. 

**필요한 이유**는 다음과 같습니다.

1. **두 호스트간 데이터 송수신 준비가 되었는지 확인하기 위해**
2. **패킷 손실 및 네트워크 오류 방지**
    - 송수신 준비가 되었는지 확인하여 모두 준비가 된 시점에 안전하게 데이터를 송수신하기 위해
3. **시퀀스 번호 동기화**
    - TCP는 각 패킷의 순서를 유지해야하기 때문에 시퀀스번호의 동기화는 필수적입니다.

# 3-way Handshake 이후에 TCP 연결을 종료하는 과정(4-way Handshake)을 설명해주세요.

---

TCP는 신뢰성있는 데이터 송수신이 메인 목적인데요. 이를 종료시점까지 이어가기위해 4-way handshake를 이용하여 연결 종료과정 또한 엄격하게 지키야 합니다.

### 4-way handshake

4-way handshake의 **동작방식**은 다음과 같습니다.

1. 클라이언트에서 서버로 FIN 전송 (연결 종료 요청)
    
    Client → Server (FIN)
    
2. 서버가 FIN에 대해 ACK를 전송 (반쪽 종료)
    
    Server → Client (ACK)
    
3. 만약 서버가 남은 데이터를 모두 보낸경우 클라이언트에게 FIN 전송
    
    Server → Client (FIN)
    
4. 클라이언트에서 서버로부터 온 FIN에 대한 ACK를 전송
    
    Client → Server (ACK)
    

위의 과정이 모두 끝나야만 두 호스트간의 TCP 연결이 끊어지게 됩니다.

# xx님이 생각하는 Restful한 API에 대해서 설명해주세요

---

제가 생각하는 Restful한 API는 REST 아키텍처 스타일을 엄격하게 따른 API 설계라고 생각합니다.

Restful API를 설계하기 위해선 **Uniform Interface, Client-Server, Stateless, Cacheable, Layered System, Self-Descriptiveness 의** 원칙을 모두 엄격하게 지켜야 한다고 생각합니다.

하지만 현실적으로 Rest 아키텍처 스타일을 엄격하게 지키는건 어렵다고 생각합니다.

따라서 저는 REST 기본 원칙을 준수하면서도, 실무 환경에서 효율적으로 API를 설계하는 것이 중요하다고 생각합니다.

즉 RESTful한 API는 단순 REST 아키텍처 스타일을 모두 따르는 것 뿐 아니라, 일관성 있는 설계와 확장성을 모두 고려하는 것이 중요하다고 생각합니다.
